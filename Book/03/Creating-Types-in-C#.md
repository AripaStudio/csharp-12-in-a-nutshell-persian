# فصل سوم : ایجاد انواع نوع داده در سی شارپ

![Conventions-UsedThis-Book](.\assets\image\03\Chapter3Constants.png)


در این فصل ما به سمت بررسی کردن انواع  داده و  اعضای نوع میپردازیم 

## کلاس ها

یک `کلاس` پرکاربردترین گونه از نوع ارجاعی است. ساده‌ترین ساختار ممکن برای اعلان یک کلاس این‌گونه است:
```Cs
class YourClassName{

}
```
یک کلاس پیچیده‌تر می‌تواند به صورت  اختیاری دارای بخش های زیر باشد : 
پیش از واژه کلیدی `class`:
صفت ها و اصلاح کننده های کلاس. اصلاح کننده های که تو در کلاس های  تو در تو نمیبینی ، عبارتند از : 
`partial` , `public` , `internal` , `abstract` , `sealed` , `static` و `unsage` 
پس از `YourClassName` : 
پارامتر های نوع عمومی (Generic Type) و محدودیت‌ها، یک کلاس پایه و رابط‌ها

### درون آکولاد ها {} : 
اعضای کلاس (این اعضا : متدها ، ویژگی ها، ایندکسرها، رویدادها ،فیلدها، سازنده‌ها ، عمگرهای سربار گذاری شده  و انواع تودرتو و یک فاینالیزر هستند).

این بخش تمام این سازه‌ها به جز صفت ها، توابع عملگر و واژه کلیدی `unsafe` را پوشش می دهد، 
که آن‌ها در فصل چهارم پوشش داده شده اند. بخش های زیر به شرح هر یک از اعضای کلاس می پردازد.


## فیلد ها (Fields) : 

یک فیلد یک متغیر است که بخشی از اعضای یک کلاس و استراکت به حساب می آید برای نمونه : 
```Cs
class Octopus{
    string name;
    public int age = 10;
}
```

فیلد ها اجازه استفاده از اصلاح‌کننده(modifers) رو دارند :
**اصلاح‌کننده‌** **استاتیک**(Static modifier) : `static` 
**اصلاح‌کننده** **دسترسی**(Access modifers ) : `public` `internal` `private` `protected`
**اصلاح‌کننده** **وراثت**(Inheritance modifier) : `new`
**اصلاح‌کننده** **ناایمن**(Unsafe modifier) : `unsafe`
**اصلاح‌کننده** **فقط-خواندنی**(Read-only modifier) : `readonly`
**اصلاح‌کننده نخ‌کشی**(Threading modifier) :  `volatile`

## پیمان‌نامه نام‌گذاری (Naming Conventions) : 
دو پیمان‌‌نامه  نام‌گذاری رایج برای فید های خصوصی وجود دارد: 
- `شتروار (camel-cased)` : firstName 
- `شتروار با خط زیرین (camel-cased with an underscore)` : _firstName 
پیمان نامه دوم به تو اجازه میده تا به سرعت فیلد‌های خصوصی را از پارامتر‌ها و متغیرهای محلی شناسایی کنی.
در بسیاری از زبان ها از پیمان‌نامه دوم استفاده میشود

## اصلاح‌کننده readonly
این اصلاح‌کننده ، فیلد را پس از ساخته شدن غیرقابل ویراش می کند.
یک فیلد فقط-خواندنی را می‌توان تنها در اعلان یا درون سازنده نوع دربرگیرنده آن مقداردهی کرد.

## مقداردهی اولیه فیلد : 
مقداردهی اولیه به فیلدها اختیاری است.
یک فیلد مقداردهی نشده ، یک مقدار پیش‌فرض دارد (برای نمونه : false , null , 0 , \0)
مقداردهی اولیه فیلد پیش از سازنده ها اجرا میشود : 
```Cs
public int Age = 10;
```
یک مقداردهی اولیه فیلد میتواند دربرگیرنده عبارت ها و فراخوانی متدها باشد : 
```Cs
static readonly string TempFolder = System.IO.Path.GetTempPath();
```
در اینجا ما از مقدار بازگشتی `GetTempPath` متغیر `TempFolder` را مقداردهی کردیم


## اعلان هم‌زمان چند فیلد (Declaring multiple fields together) : 

برای آسان سازی ، ما میتوانیم چندین فیلد را از یک نوع را با یک فهرست جداشده با کاما اعلان کنیم.
این روش مناسب برای اشتراک‌گذاری صفت ها و اصلاح‌کننده های فیلد است : 
```Cs
static readonly int legs = 8,
                    eyse = 2;
```

## ثابت ها (Constants) : 
یک ثابت به صورت ایستا و در زمان کامپایل ارزیابی میشود و کامپایلر در هر جایی که از آن استفاده شود ، مقدارش را جایگزین میکند (مانند ماکرو در زبان C++ ).
یک ثابت می‌تواند از نوع `string` , `char` , `bool`و هر یک از انواع عددی داخلی یا یک نوع `enum` باشد.


یک ثابت با واژه کلیدی `const` اعلان می‌شود و باید با یک مقدار مقداردهی اولیه شود.
برای نمونه : 
```Cs
public class Test{
    public const string Message = "Hello World!";
}
```
یک ثابت میتواند نقشی همانند یک فیلد `static readonly` داشته باشد ، اما بسیار محدودتر است،
هم از نظر نوع‌هایی که میتوانی به کار ببری و هم از نظر معنای مقداردهی اولیه فیلد.

یک ثابت همچنین با فیلد `static readonly` فرق دارد ، زیرا ارزیابی ثابت در زمان کامپایل رخ میدهد ، از این رو :
```Cs
public static double Circumference (double radius)
{
 return 2 * System.Math.PI * radius;
}
```
به این صورت کامپایل میشود : 
```Cs
public static double Circumference (double radius)
{
 return 6.2831853071795862 * radius;
}

```
برای عدد `PI` منطقی است که ثابت باشد ، چرا که مقدار آن در زمان کامپایل از پیش تعیین شده است.
در مقابل ، مقدار یک فیلد `static readonly` می تواند هر بار که برنامه اجرا می شود، متفاوت باشد:
```Cs
static readonly DateTime StartupTime = DateTime.Now;
```

یک فیلد `static readonly` هنگامی که یک مقدار را به اسمبلی های دیگر نمایش می‌دهی و ممکن است آن مقدار در نسخه بعدی تغییر کند ، مزیت دارد. برای نمونه ، فرض کن اسمبلی `X` یک ثابت را این گونه نمایش میدهد:
```Cs
public const decimal ProgramVersion = 2.3;
```
اگر اسمبلی `Y` به `X` ارجاع دهد و از این ثابت استفاده کند، مقدار `2.3` در زمان کامپایل در اسمبلی `Y` جاسازی می‌شود. این به این معنی است که اگر بعدها `X` با ثابت `2.4` دوباره کامپایل شود، `Y` همچنان از مقدار قدیمی `2.3` استفاده خواهد کرد، تا زمانی که `Y` دوباره کامپایل شود. یک فیلد `static readonly` از این مشکل جلوگیری می‌کند.
از نگاهی دیگر، هر مقداری که ممکن است در آینده تغییر کند، به تعریف «ثابت» نیست؛ بنابراین نباید به این شکل نمایش داده شود.

ثابت ها می توانند در درون یک متد نیز اعلان شوند : 
```Cs
void TestPI(){
    const double twoPI = 2 * System.Math.PI;
    //...
}
```
ثابت های غیر محلی اجازه استفاده از اصلاح کننده های زیر را دارند : 
**اصلاح‌کننده های دسترسی** : 
`private` `public` `internal` `protected`
**اصلاح‌کننده وراثت**:
`new`

## متد ها (Methods)
متد ها یکی از مفاهیم مهم در تمام زبان های برنامه نویسی است ،
یک متد ، یک کار را در یک سری از دستور ها انجام میدهد.
یک متد میتواند با شناساندن پارامتر‌ها ، داده‌های ورودی را از فراخواننده بگیرد و با شناساندن یک گونه‌ی بازگشتی، داده‌ها را به فراخواننده بازگرداند،
اگر بخواهیم کمی ساده تر توضیح دهیم ، متد ها مانند یک جعبه ابزار هستن به آنها مقدار اولیه را میدهیم و روی آن مقدار کاری را انجام میدهد و چیزی را پس میدهد.
یک متد میتواند یک گونه‌ی بازگشتی `void` را شناساند که نشان می‌دهد هیچ ارزشی(مقداری) را به فراخواننده‌ی خویش باز نمی‌گرداند.
یک متد همچنین میتواند داده‌ها را از راه پارامتر های `ref` و `out` به فراخواننده بازگردانند
(مانند پوینتر ها در زبان `C`)

امضای یک متد باید در درون یک گونه (type) بی همتا باشد. امضای یک متد ، از نام آن و گونه های پارامترها به ترتیب (اما نه نام پارامترها و نه گونه‌ی بازگشتی) تشکیل شده است.

- `پی نوشت : ` پالایشگاه : اصلاح‌کننده
واژه `اصلاح‌کننده` یک واژه عربی است و واژه `پالایشگاه یا پالایشگر` معادل پارسی آن است هر دو درست هستند.


متدها اجازه‌ی به کارگیری پالایشگرهای (modifiers) زیر را میدهد : 
- اصلاح‌کننده ایستا (Static modifier) : `static`
- اصلاح‌کننده های دسترسی (Access modifiers) : 
```Cs
public , internal , private , protected
```
- اصلاح‌کننده ارث‌ بری (Inheritance modifiers) : 
```Cs
new , virtual , abstract , override , sealed
```
- اصلاح‌کننده متد پاره‌ای(Partial method modifier) : `partial`

- اصلاح‌کننده کد ناهمزمان (Asynchronous code modifier) : 
`async`
نمونه : 
```Cs
static async Task Main(string[] args)
{
    Console.WriteLine("Starting...");
    await Task.Delay(3000);
    Console.WriteLine("Finished.");
}
```

**Task در C# نمایانگر یک عملیات ناهمزمان (asynchronous) است که می‌تواند در آینده به پایان برسد. این امکان را می‌دهد که برنامه به انجام کارهای دیگر ادامه دهد در حالی که منتظر نتیجه یک عملیات طولانی‌مدت است. در فصل های آینده در این باره بیشتر یاد خواهید گرفت**


## متد‌های بیان-پیکر  (Expression-bodied methods)
یک متد که از یک تک‌‌‌ بیان (single expression) ساخته شده است ، مانند : 
```Cs
int foo (int x) {
    return x * 2;
}
```
میتوانید به گونه‌ای کوتاه تر به شکل یک متد بیان-پیکر نوشته شود. در این شیوه ، یک پیکان فربه (`=>`) جای آکولاد‌ها و کلیدواژه‌ی `return` استفاده میگردد : 
```Cs
int foo (int x) => Console.WriteLine(x);
```
**همیشه به یاد داشته باشید کد بلند نشان بهتر بودن نیست همیشه کد را بهینه تر و کوتاه تر بکنید و قابل فهم تر**


### متد های بومی (Local methods)
شما میتوانید یک متد را در درون یک متد دیگر شناسایی کنید : 
```Cs
void WriteCubes(){
    Console.WriteLine(Cube(3));
    Console.WriteLine(Cube(4));
    Console.WriteLine(Cube(5));
    int Cube (int value) => value * value * value;
}
```

متد های بومی (در این نمونه `Cube`) تنها برای متد دربرگیرنده (در این نمونه `WriteCubes`) دیدنی است(دیدنی است به این معنا که دردسترس است). این کار ، گونه‌ی دربرگیرنده را ساده تر میکند و به همه‌ی کسانی که به کد نگاه میکنند، بی درنگ نشان می‌دهد که `Cube` در هیچ جای دیگری به کار نمی‌رود. یک فایده‌ی دیگر متد های بومی این است که می توانید  به متغیرهای بومی و پارامترهای متد دربرگیرنده دسترسی داشته باشید.
این کار، پیامدهای زیادی دارد که در بخش های آینده به ریزنگاری آن ها میپردازیم.


متدهای بومی میتوانند در درون گونه‌های کنشی دیگر نیز پدیدار شوند، مانند دسترسی سازهای ویژوگی(property accessors)، سازنده‌ها و مانند آن‌ها. شما حتی میتوانید متدهای بومی را در درون متدهای  بومی را در درون متدهای بومی دیگر و در درون بیان‌های لامبدا که از یک بلوک دستور بهره می‌برند، بگذارید. متدهای بومی می‌توانند پیمایشگر (iterators) یا ناهمزمان (asynchronous) باشند.


### متدهای بومی ایستای (Static local methods)
افزودن پالایشگر `static` به یک متد بومی (از C# 8) از دیدن متغیرهای بومی و پارامترهای متد دربرگیرنده توسط آن، پیشگیری کند.
این کار به کاستن همبستگی کمک کرده و از ارجاع ناخواسته متد بومی به متغیر های متد دربرگیرنده جلوگیری میکند.

نمونه : 
```Cs
static int CalculateSquare(int n)
{
    // متد بومی ایستای برای محاسبه مربع
    static int Square(int x)
    {
        return x * x;
    }

    return Square(n);

    //یا به صورت خلاصه تر : 
    static int Square(int x) => return x * x;
}
```

### متدهای بومی و دستورهای سطح-بالا(Top-level statements)
هر متدی که در دستورهای سطح-بالا شناسایی کنید، یک متد بومی شمرده میشود.
این بدان معناست که (اگر با `static` نشان‌گذاری نشده باشد)
میتوانید به متغیرهای دروندستورهای سطح-بالا دسترسی داشته باشید : 
```Cs
int x = 3;
void Foo() => Console.WriteLine(x);
```

### پربارسازی متدها (Overloading methods)
متدهای بومی نمی‌توانند پربارسازی شوند. این بدان معناست که متدهای که در دستور های سطح-بالا شناسایی شده‌اند(که متدهای بومی شمرده میشوند) نمی توانند پربارسازی شوند.

یک گونه می‌تواند متدها را پربارسازی کند(چند متد با نام یکسان شناسایی کند) تا زمانی که امضاها ناهمسان باشند.
برای نمونه، همه‌ی متدهای زیر میتوانند در یک گونه همزیستی داشته باشند:
```Cs
void Foo (int x){}
void Foo(double x){}
void Foo (int x , float y){}
void Foo(float x, int y){}
```

با این همه، جفت متدهای زیر نمی‌توانند در یک گونه همزیستی داشته باشند، زیرا گونه‌ی بازگشتی و پالایشگر `params` بخشی از امضای یک متد نیستند:
```Cs
void Foo (int x) {}
float Foo (int x) {} 

void Goo (int[] x) {}
void Goo (params int[] x) {} 
```

این که یک پارامتر با ارزش می‌گذرد یا با ارجاع، نیز بخشی از امضا است.
برای نمونه، `Foo(int)` می‌تواند با `Foo(ref int)` یا `Foo(out int)` همزیستی داشته باشد. با این همه، `Foo(ref int)` و `Foo(out int)` نمی‌توانند همزیستی داشته باشند:
```Cs
void Foo (int x) {}
void Foo (ref int x) {}
void Foo (out int x) {} 
```


### سازنده‌های نمونه‌ای (Instance Constructors)
سازنده‌ها کد آغازگری را در یک کلاس یا ساختار به کار می‌اندازند. یک سازنده مانند یک متد شناسایی می‌شود، جز اینکه نام متد و گونه‌ی بازگشتی به نام گونه‌ی دربرگیرنده کاهش می‌یابد:
```Cs
Panda p = new Panda ("Petey");

public class Panda
{
 string name;
 public Panda (string n)
 {
 name = n;
 }
}
```
سازنده های نمونه‌ای اجازه‌ی به‌کارگیری پالایشگرهای زیر را میدهند :
- پالایشگرهای دسترسی (Access modifiers)
`public internal private protected`
- پالایشگرهای کد بی‌مدیریت (Unmanaged code modifiers)
`unsafe extern`

سازنده های تک دستوری نیز میتوانند به عنوان اندام های بیان-پیکر نوشته شوند: 
```Cs
public Panda (string n) => name = n;
```
اگر نام یک پارامتر(یا هر نام متغیر دیگری) با نام یک فیلد هم‌پوشانی داشته باشد، میتوانید با پیشوند `this` فیلد را از هم باز شناسید:
```Cs
public Panda (string name ) => this.name = name;
```
برای نمونه  بهتر :
```Cs
public class LearnCsharp{
    public string name = "";

    public Panda(string name) => this.name = name;
    //در اصل نام اولی به فیلد اشاره میکند و دومی به پارامتر در  متد
}
```

### پربارسازی سازنده‌ها(Overloading constructors)
یک کلاس یا ساختار میتواند سازنده‌ها را پربارسازی کند.
برای پرهیز از تکرار کد(که خیلی مهم است )، یک سازنده میتواند سازنده‌ی دیگری را با بهره‌گیری از کلیدواژه‌ی `this` فراخوانی کند :
```Cs
public class Wine{
    public decimal Price;
    public int Year;
    public Wine (decimal price) => Price = price;
    public Wine (decimal price, int year) : this (price) => Year = year;    
}
```
زمانی که یک سازنده، دیگری را فراخوانی میکند، سازنده‌ی فراخوانده شده نخست اجرا میشود.

شما میتوانید یک بیان (expression) را به درون سازنده‌ی دیگر بفرستید، به گونه ای که در زیر آمده است :
```Cs
public Wine (decimal price, DateTime year) : this (price, year.Year) { }
```

این بیان می‌تواند به اندام های ایستا (static) کلاس دسترسی داشته باشد، اما به اندام های نمونه ای(instance) نه.

این نمونه‌ی ویژه میتواند به گونه‌ای بهتر با یک سازنده‌ی تکی که سال را به عنوان یک پارامتر دلخواه(optional) دارد ، پیاده سازی شود :
```Cs
public Wine (decimal price, int year = 0)
{
    Price = price; Year = year;
}
```


### سازنده‌های بدون پارامتر ضمنی (Implicit parameterless constructors)
برای کلاس‌ها گردآورنده‌ی C# به خودی خود یک سازنده‌ی بدون پارامتر `public` را تنها زمانی پدید می آورد که شما هیچ سازنده‌ای را شناسایی نکرده باشید.
با این همه ، به محض این که دست کم یک سازنده‌ را شناسایی کنید آن سازنده‌ی بدون بدون پارامتر دیگر به خودی خود پدیدار نمی‌شود.

برای درک بهتر این موضوع : 

```Cs
public class MyClass
{
}

MyClass obj1 = new MyClass();

public class MyClassWithConstructor
{
    public MyClassWithConstructor(int value)
    {
    }
}

MyClassWithConstructor obj2 = new MyClassWithConstructor(10);
```
به این معناست :
در زبان C#، اگر شما یک کلاس را تعریف کنید و هیچ سازنده‌ای برای آن مشخص نکنید، کامپایلر به طور خودکار یک سازنده‌ی بدون پارامتر (Implicit parameterless constructor) برای آن کلاس ایجاد می‌کند. اما اگر شما یک سازنده‌ی دیگر (مثلاً با پارامتر) تعریف کنید، آن سازنده‌ی بدون پارامتر دیگر به طور خودکار ایجاد نخواهد شد.


### ترتیب آغازگری سازنده و فیلد (Constructor and field initialization)
پیش از این دیدیم که فیلد‌ها می توانند با ارزش های پیش گزیده در شناسایی شان، آغاز گردنند:
```Cs
class player{
    int shields = 50;
    int health = 100;
}
```
آغازگری فیلدها پیش از اجرای سازنده و به ترتیب شناسایی فیلدها ، رخ میدهد

### سازنده‌های غیرهمگانی (Nonpublic constructors)
سازنده ها نیاز نیست `public` باشند.
یک شوند همگانی برای داشتن یک سازنده‌ی غیرهمگانی، چیره شدن بر پدیدآوری نمونه از راه یک فراخوانی متد `static` است. متد `static` می‌تواند برای بازگرداندن یک شیء از یک استخر (pool)، به جای پدیدآوری یک شیء نو، یا برای بازگرداندن زیرکلاس‌های گوناگون بر پایه‌ی آرگومان‌های ورودی به کار رود:

```Cs
public class Class1
{
 Class1() {}
 public static Class1 Create (...)
 {
 // Perform custom logic here to return an instance of Class1
 }
}
```

### پادسازنده‌ها (Deconstructors)
یک پادسازنده (که با نام "متد پادسازنده" نیز خوانده میشود) کارکردی درست برعکس یک سازنده دارد :
درحالی که یک سازنده به گونه‌ای همگانی یک سری از ارزش‌ها را (به عنوان پارامتر) می‌گیرد و به فیلدها می‌سپارد، یک پادسازنده کار برعکس را انجام می دهد و فیلدها را به  یک سری از متغیر ها میسپارد.

یک متد پادسازنده باید `Deconstruct` نامیده شود و باید یک یا چند پارامتر `out` داشته باشد، مانند نمونه زیر : 

```Cs
class Rectangle{
     public readonly float Width, Height;
    
    public Rectangle (float width, float height)
    {
        Width = width;
        Height = height;
    }
    
    
    public void Deconstruct (out float width, out float height)
    
    {
    
    width = Width;
    
    height = Height;
    
    }
}

```

دستور ویژه زیر ، پادسازنده را فراخوانی میکند:
```Cs
var rect = new Rectangle (3, 4);
(float width, float height) = rect; // پادسازی
Console.WriteLine (width + " " + height); // 3 4
```

سطر دوم، فراخوانی پادسازی است، . این سطر ، دو متغیر بومی را می‌سازد و سپس متد `Deconstruct` را فراخوانی میکند. 
فراخوانی پادسازی ما به نمونه‌ی زیر هم ارز است : 
```Cs
float width , height;
rect.Deconstruct(out width , out height);
```
یا :
```Cs
(var width, var height) = rect;
```

یا به سادگی به این گونه :
```Cs
var (width, height) = rect;
```

اگر به یک یا چند متغیر بی‌میل هستید ، می توانید از نماد دورریز(`_`) سی شارپ بهره ببرید : 
```Cs
var (_ , height) = rect;
```

این کار، به درستی نیت شما را نسبت به شناسایی یک متغیر که هرگز از آن بهره نمی برید  را نشان میدهد.

اگر متغیرهایی که در آن ها پادسازی می کنید از پیش شناسایی شده اند، می توانید گونه‌ها را به کلی نادیده بگیرید : 

```Cs
float width, height;
(width, height) = rect;
```

این کار، واگذاری پادسازی (**deconstructing assignment**) نامیده می‌شود. شما می‌توانید از یک واگذاری پادسازی برای ساده‌تر کردن سازنده‌ی کلاس خود بهره ببرید:

```Cs
public Rectangle (float width, float height) =>
 (Width, Height) = (width, height);
```

شما می‌توانید با پربارسازی متد `Deconstruct،` گزینه‌های گوناگونی برای پادسازی به فراخواننده پیشکش کنید.

متد `Deconstruct` می‌تواند یک متد گسترشی (**extension method**) باشد. این کار یک ترفند کارآمد است اگر می‌خواهید گونه‌هایی را پادسازی کنید که شما نویسنده‌ی آن‌ها نبوده‌اید.

از **سی‌شارپ 10**، می‌توانید متغیرهای از پیش موجود و متغیرهای نو را زمانی که پادسازی می‌کنید، با هم درآمیزید:

```Cs
double x1 = 0;
(x1, double y2) = rect;
```


### آغازگرهای شیء (Object Initializers)

برای ساده‌ترک ردنآغازگری شیء، هر فیلد یا ویژگی(`property`) دسترسی پذیر یک شیء میتوانید از راه یک **آغازگر شیء** ، درست  پس از ساخت ، مقداردهی شود. برای نمونه ، کلاس زیر را در نظر بگیرید : 

```Cs
public class Bunny
{
    public string Name;
    public bool LikesCarrots, LikesHumans;
    public Bunny () {}
    public Bunny (string n) => Name = n;
}
```

با بهره‌گیری از آغازگرهای شیء، میتوانید نمونه های کلاس `Bunny` را به این گونه پدید آورید : 

```Cs
// به یاد داشته باشید که سازنده‌های بدون پارامتر می‌توانند پرانتزهای خالی را نادیده بگیرند
Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };
Bunny b2 = new Bunny ("Bo") { LikesCarrots=true, LikesHumans=false };
```

کد برای ساخت `b1` و `b2` با کد زیر هم‌ارز است:
```Cs
Bunny temp1 = new Bunny();
temp1.Name = "Bo";
temp1.LikesCarrots = true;
temp1.LikesHumans = false;
Bunny b1 = temp1;

Bunny temp2 = new Bunny ("Bo");
temp2.LikesCarrots = true;
temp2.LikesHumans = false;
Bunny b2 = temp2;
```
متغیرهای موقت برای این هستند که اگر در زمان آغازگری، یک کژکاری (`exception`) رخ دهد، شما یک شیء نیمه‌آغازگری‌شده نداشته باشید.


> ### آغازگرهای شیء در برابر پارامترهای دلخواه (Optional Parameters)
>
> به جای وابستگی به آغازگرهای شیء، می‌توانستیم سازنده‌ی `Bunny` را به گونه‌ی زیر، با یک پارامتر بایسته (`mandatory`) و دو پارامتر دلخواه، بنویسیم:
> 
> ```csharp
> public Bunny (string name,
>  bool likesCarrots = false,
>  bool likesHumans = false)
> {
>  Name = name;
>  LikesCarrots = likesCarrots;
>  LikesHumans = likesHumans;
> }
> ```
> 
> این کار به ما پروانه‌ی ساخت یک `Bunny` را به این گونه می‌داد:
> 
> ```csharp
> Bunny b1 = new Bunny (name: "Bo",
>  likesCarrots: true);
> ```
> 
> به گونه‌ای تاریخی، وابستگی به سازنده‌ها برای آغازگری شیء، سودمند بود؛ چرا که به ما پروانه‌ی خواندنی-تنها کردن فیلدها (یا ویژگی‌های) `Bunny` را می‌داد. خواندنی-تنها کردن فیلدها یا ویژگی‌ها، یک شیوه‌ی نیکو است زمانی که هیچ چرایی برای دگرگونی آن‌ها در سراسر زندگی شیء نیست. با این همه، همان گونه که در آینده در گفتگو درباره‌ی ویژگی‌ها خواهیم دید، پالایشگر `init` که در سی‌شارپ 9 پدیدار شد، به ما پروانه‌ی رسیدن به این هدف را با آغازگرهای شیء می‌دهد.
>
> پارامترهای دلخواه، دو کاستی دارند. نخست این که در حالی که بهره‌گیری از آن‌ها در سازنده‌ها به گونه‌های خواندنی-تنها پروانه می‌دهد، به آسانی به دگرگونی‌های غیرمخرب (`nondestructive mutation`) پروانه نمی‌دهند. (درباره‌ی دگرگونی‌های غیرمخرب و راه‌کار این دشواری، در آینده خواهیم گفت).
>
> دومین کاستی پارامترهای دلخواه این است که زمانی که در کتابخانه‌های همگانی به کار می‌روند، جلوی سازگاری با نسخه‌های پیشین را می‌گیرند. این به آن شوند است که افزودن یک پارامتر دلخواه در آینده، سازگاری دودویی (`binary compatibility`) اسمبلی را با فراخوانندگان از پیش موجود از بین می‌برد.
>
> دشواری از این جاست که هر ارزش پارامتر دلخواه در فراخوانی‌گاه (`calling site`) پخته می‌شود. به سخن دیگر، سی‌شارپ، فراخوانی سازنده‌ی ما را به این گونه برمی‌گرداند:
> 
> ```csharp
> Bunny b1 = new Bunny ("Bo", true, false);
> ```
> 
> این کار پرمسئله است اگر ما نمونه‌ی `Bunny` را از یک اسمبلی دیگر بسازیم و در آینده با افزودن یک پارامتر دلخواه دیگر مانند `likesCats`، `Bunny` را دگرگون کنیم. اگر اسمبلی ارجاع‌دهنده دوباره گردآوری (`recompiled`) نشود، همچنان به فراخوانی سازنده‌ی (که اکنون نیست) با سه پارامتر ادامه می‌دهد و در زمان اجرا شکست می‌خورد.


## رجاع `this` (The `this` Reference)

ارجاع `this` به خود نمونه اشاره دارد. در نمونه‌ی زیر، متد `Marry` از `this` بهره می‌برد تا فیلد `mate` همراه را مقداردهی کند:
```cs
public class Panda
{
    public Panda Mate;
    public void Marry (Panda partner)
    {
        Mate = partner;
        partner.Mate = this;
    }
}
```
ارجاع `this` همچنین یک متغیر بومی یا پارامتر را از یک فیلد باز می‌شناساند؛ برای نمونه:
```cs
public class Test
{
    string name;
    public Test (string name) => this.name = name;
}
```
ارجاع `this` تنها در درون اندام‌های غیرایستای یک کلاس یا ساختار، کارآمد است.