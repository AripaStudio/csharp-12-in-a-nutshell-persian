# فصل سوم : ایجاد انواع نوع داده در سی شارپ

![Conventions-UsedThis-Book](/assets/image/03/ImageStartChapter3.png)


در این فصل ما به سمت بررسی کردن انواع  داده و  اعضای نوع میپردازیم 

## کلاس ها

یک `class` پرکاربردترین گونه از نوع ارجاعی است. ساده‌ترین ساختار ممکن برای اعلان یک کلاس این‌گونه است:
```Cs
class YourClassName{

}
```
یک کلاس پیچیده‌تر می‌تواند به صورت  اختیاری دارای بخش های زیر باشد : 
پیش از واژه کلیدی `class`:
صفت ها و اصلاح کننده های کلاس. اصلاح کننده های که تو در کلاس های  تو در تو نمیبینی ، عبارتند از : 
`partial` , `public` , `internal` , `abstract` , `sealed` , `static` و `unsage` 
پس از `YourClassName` : 
پارامتر های نوع عمومی (Generic Type) و محدودیت‌ها، یک کلاس پایه و رابط‌ها

### درون آکولاد ها {} : 
اعضای کلاس (این اعضا : متدها ، ویژگی ها، ایندکسرها، رویدادها ،فیلدها، سازنده‌ها ، عمگرهای سربار گذاری شده  و انواع تودرتو و یک فاینالیزر هستند).

این بخش تمام این سازه‌ها به جز صفت ها، توابع عملگر و واژه کلیدی `unsafe` را پوشش می دهد، 
که آن‌ها در فصل چهارم پوشش داده شده اند. بخش های زیر به شرح هر یک از اعضای کلاس می پردازد.


## فیلد ها (Fields) : 

یک فیلد یک متغیر است که بخشی از اعضای یک کلاس و استراکت به حساب می آید برای نمونه : 
```Cs
class Octopus{
    string name;
    public int age = 10;
}
```

فیلد ها اجازه استفاده از اصلاح‌کننده(modifers) رو دارند :
**اصلاح‌کننده‌** **استاتیک**(Static modifier) : `static` 
**اصلاح‌کننده** **دسترسی**(Access modifers ) : `public` `internal` `private` `protected`
**اصلاح‌کننده** **وراثت**(Inheritance modifier) : `new`
**اصلاح‌کننده** **ناایمن**(Unsafe modifier) : `unsafe`
**اصلاح‌کننده** **فقط-خواندنی**(Read-only modifier) : `readonly`
**اصلاح‌کننده نخ‌کشی**(Threading modifier) :  `volatile`

## پیمان‌نامه نام‌گذاری (Naming Conventions) : 
دو پیمان‌‌نامه  نام‌گذاری رایج برای فید های خصوصی وجود دارد: 
- `شتروار (camel-cased)` : firstName 
- `شتروار با خط زیرین (camel-cased with an underscore)` : _firstName 
پیمان نامه دوم به تو اجازه میده تا به سرعت فیلد‌های خصوصی را از پارامتر‌ها و متغیرهای محلی شناسایی کنی.
در بسیاری از زبان ها از پیمان‌نامه دوم استفاده میشود

## اصلاح‌کننده readonly
این اصلاح‌کننده ، فیلد را پس از ساخته شدن غیرقابل ویراش می کند.
یک فیلد فقط-خواندنی را می‌توان تنها در اعلان یا درون سازنده نوع دربرگیرنده آن مقداردهی کرد.

## مقداردهی اولیه فیلد : 
مقداردهی اولیه به فیلدها اختیاری است.
یک فیلد مقداردهی نشده ، یک مقدار پیش‌فرض دارد (برای نمونه : false , null , 0 , \0)
مقداردهی اولیه فیلد پیش از سازنده ها اجرا میشود : 
```Cs
public int Age = 10;
```
یک مقداردهی اولیه فیلد میتواند دربرگیرنده عبارت ها و فراخوانی متدها باشد : 
```Cs
static readonly string TempFolder = System.IO.Path.GetTempPath();
```
در اینجا ما از مقدار بازگشتی `GetTempPath` متغیر `TempFolder` را مقداردهی کردیم


## اعلان هم‌زمان چند فیلد (Declaring multiple fields together) : 

برای آسان سازی ، ما میتوانیم چندین فیلد را از یک نوع را با یک فهرست جداشده با کاما اعلان کنیم.
این روش مناسب برای اشتراک‌گذاری صفت ها و اصلاح‌کننده های فیلد است : 
```Cs
static readonly int legs = 8,
                    eyse = 2;
```

## ثابت ها (Constants) : 
یک ثابت به صورت ایستا و در زمان کامپایل ارزیابی میشود و کامپایلر در هر جایی که از آن استفاده شود ، مقدارش را جایگزین میکند (مانند ماکرو در زبان C++ ).
یک ثابت می‌تواند از نوع `string` , `char` , `bool`و هر یک از انواع عددی داخلی یا یک نوع `enum` باشد.


یک ثابت با واژه کلیدی `const` اعلان می‌شود و باید با یک مقدار مقداردهی اولیه شود.
برای نمونه : 
```Cs
public class Test{
    public const string Message = "Hello World!";
}
```
یک ثابت میتواند نقشی همانند یک فیلد `static readonly` داشته باشد ، اما بسیار محدودتر است،
هم از نظر نوع‌هایی که میتوانی به کار ببری و هم از نظر معنای مقداردهی اولیه فیلد.

یک ثابت همچنین با فیلد `static readonly` فرق دارد ، زیرا ارزیابی ثابت در زمان کامپایل رخ میدهد ، از این رو :
```Cs
public static double Circumference (double radius)
{
 return 2 * System.Math.PI * radius;
}
```
به این صورت کامپایل میشود : 
```Cs
public static double Circumference (double radius)
{
 return 6.2831853071795862 * radius;
}

```
برای عدد `PI` منطقی است که ثابت باشد ، چرا که مقدار آن در زمان کامپایل از پیش تعیین شده است.
در مقابل ، مقدار یک فیلد `static readonly` می تواند هر بار که برنامه اجرا می شود، متفاوت باشد:
```Cs
static readonly DateTime StartupTime = DateTime.Now;
```

یک فیلد `static readonly` هنگامی که یک مقدار را به اسمبلی های دیگر نمایش می‌دهی و ممکن است آن مقدار در نسخه بعدی تغییر کند ، مزیت دارد. برای نمونه ، فرض کن اسمبلی `X` یک ثابت را این گونه نمایش میدهد:
```Cs
public const decimal ProgramVersion = 2.3;
```
اگر اسمبلی `Y` به `X` ارجاع دهد و از این ثابت استفاده کند، مقدار `2.3` در زمان کامپایل در اسمبلی `Y` جاسازی می‌شود. این به این معنی است که اگر بعدها `X` با ثابت `2.4` دوباره کامپایل شود، `Y` همچنان از مقدار قدیمی `2.3` استفاده خواهد کرد، تا زمانی که `Y` دوباره کامپایل شود. یک فیلد `static readonly` از این مشکل جلوگیری می‌کند.
از نگاهی دیگر، هر مقداری که ممکن است در آینده تغییر کند، به تعریف «ثابت» نیست؛ بنابراین نباید به این شکل نمایش داده شود.

ثابت ها می توانند در درون یک متد نیز اعلان شوند : 
```Cs
void TestPI(){
    const double twoPI = 2 * System.Math.PI;
    //...
}
```
ثابت های غیر محلی اجازه استفاده از اصلاح کننده های زیر را دارند : 
**اصلاح‌کننده های دسترسی** : 
`private` `public` `internal` `protected`
**اصلاح‌کننده وراثت**:
`new`

## متد ها (Methods)
متد ها یکی از مفاهیم مهم در تمام زبان های برنامه نویسی است ،
یک متد ، یک کار را در یک سری از دستور ها انجام میدهد.
یک متد میتواند با شناساندن پارامتر‌ها ، داده‌های ورودی را از فراخواننده بگیرد و با شناساندن یک گونه‌ی بازگشتی، داده‌ها را به فراخواننده بازگرداند،
اگر بخواهیم کمی ساده تر توضیح دهیم ، متد ها مانند یک جعبه ابزار هستن به آنها مقدار اولیه را میدهیم و روی آن مقدار کاری را انجام میدهد و چیزی را پس میدهد.
یک متد میتواند یک گونه‌ی بازگشتی `void` را شناساند که نشان می‌دهد هیچ ارزشی(مقداری) را به فراخواننده‌ی خویش باز نمی‌گرداند.
یک متد همچنین میتواند داده‌ها را از راه پارامتر های `ref` و `out` به فراخواننده بازگردانند
(مانند پوینتر ها در زبان `C`)

امضای یک متد باید در درون یک گونه (type) بی همتا باشد. امضای یک متد ، از نام آن و گونه های پارامترها به ترتیب (اما نه نام پارامترها و نه گونه‌ی بازگشتی) تشکیل شده است.

- `پی نوشت : ` پالایشگاه : اصلاح‌کننده
واژه `اصلاح‌کننده` یک واژه عربی است و واژه `پالایشگاه یا پالایشگر` معادل پارسی آن است هر دو درست هستند.


متدها اجازه‌ی به کارگیری پالایشگرهای (modifiers) زیر را میدهد : 
- اصلاح‌کننده ایستا (Static modifier) : `static`
- اصلاح‌کننده های دسترسی (Access modifiers) : 
```Cs
public , internal , private , protected
```
- اصلاح‌کننده ارث‌ بری (Inheritance modifiers) : 
```Cs
new , virtual , abstract , override , sealed
```
- اصلاح‌کننده متد پاره‌ای(Partial method modifier) : `partial`

- اصلاح‌کننده کد ناهمزمان (Asynchronous code modifier) : 
`async`
نمونه : 
```Cs
static async Task Main(string[] args)
{
    Console.WriteLine("Starting...");
    await Task.Delay(3000);
    Console.WriteLine("Finished.");
}
```

**Task در C# نمایانگر یک عملیات ناهمزمان (asynchronous) است که می‌تواند در آینده به پایان برسد. این امکان را می‌دهد که برنامه به انجام کارهای دیگر ادامه دهد در حالی که منتظر نتیجه یک عملیات طولانی‌مدت است. در فصل های آینده در این باره بیشتر یاد خواهید گرفت**


### متد‌های بیان-پیکر  (Expression-bodied methods)
یک متد که از یک تک‌‌‌ بیان (single expression) ساخته شده است ، مانند : 
```Cs
int foo (int x) {
    return x * 2;
}
```
میتوانید به گونه‌ای کوتاه تر به شکل یک متد بیان-پیکر نوشته شود. در این شیوه ، یک پیکان فربه (`=>`) جای آکولاد‌ها و کلیدواژه‌ی `return` استفاده میگردد : 
```Cs
int foo (int x) => Console.WriteLine(x);
```
**همیشه به یاد داشته باشید کد بلند نشان بهتر بودن نیست همیشه کد را بهینه تر و کوتاه تر بکنید و قابل فهم تر**


### متد های بومی (Local methods)
شما میتوانید یک متد را در درون یک متد دیگر شناسایی کنید : 
```Cs
void WriteCubes(){
    Console.WriteLine(Cube(3));
    Console.WriteLine(Cube(4));
    Console.WriteLine(Cube(5));
    int Cube (int value) => value * value * value;
}
```

متد های بومی (در این نمونه `Cube`) تنها برای متد دربرگیرنده (در این نمونه `WriteCubes`) دیدنی است(دیدنی است به این معنا که دردسترس است). این کار ، گونه‌ی دربرگیرنده را ساده تر میکند و به همه‌ی کسانی که به کد نگاه میکنند، بی درنگ نشان می‌دهد که `Cube` در هیچ جای دیگری به کار نمی‌رود. یک فایده‌ی دیگر متد های بومی این است که می توانید  به متغیرهای بومی و پارامترهای متد دربرگیرنده دسترسی داشته باشید.
این کار، پیامدهای زیادی دارد که در بخش های آینده به ریزنگاری آن ها میپردازیم.


متدهای بومی میتوانند در درون گونه‌های کنشی دیگر نیز پدیدار شوند، مانند دسترسی سازهای ویژوگی(property accessors)، سازنده‌ها و مانند آن‌ها. شما حتی میتوانید متدهای بومی را در درون متدهای  بومی را در درون متدهای بومی دیگر و در درون بیان‌های لامبدا که از یک بلوک دستور بهره می‌برند، بگذارید. متدهای بومی می‌توانند پیمایشگر (iterators) یا ناهمزمان (asynchronous) باشند.


### متدهای بومی ایستای (Static local methods)
افزودن پالایشگر `static` به یک متد بومی (از C# 8) از دیدن متغیرهای بومی و پارامترهای متد دربرگیرنده توسط آن، پیشگیری کند.
این کار به کاستن همبستگی کمک کرده و از ارجاع ناخواسته متد بومی به متغیر های متد دربرگیرنده جلوگیری میکند.

نمونه : 
```Cs
static int CalculateSquare(int n)
{
    // متد بومی ایستای برای محاسبه مربع
    static int Square(int x)
    {
        return x * x;
    }

    return Square(n);

    //یا به صورت خلاصه تر : 
    static int Square(int x) => return x * x;
}
```

### متدهای بومی و دستورهای سطح-بالا(Top-level statements)
هر متدی که در دستورهای سطح-بالا شناسایی کنید، یک متد بومی شمرده میشود.
این بدان معناست که (اگر با `static` نشان‌گذاری نشده باشد)
میتوانید به متغیرهای دروندستورهای سطح-بالا دسترسی داشته باشید : 
```Cs
int x = 3;
void Foo() => Console.WriteLine(x);
```

### پربارسازی متدها (Overloading methods)
متدهای بومی نمی‌توانند پربارسازی شوند. این بدان معناست که متدهای که در دستور های سطح-بالا شناسایی شده‌اند(که متدهای بومی شمرده میشوند) نمی توانند پربارسازی شوند.

یک گونه می‌تواند متدها را پربارسازی کند(چند متد با نام یکسان شناسایی کند) تا زمانی که امضاها ناهمسان باشند.
برای نمونه، همه‌ی متدهای زیر میتوانند در یک گونه همزیستی داشته باشند:
```Cs
void Foo (int x){}
void Foo(double x){}
void Foo (int x , float y){}
void Foo(float x, int y){}
```

با این همه، جفت متدهای زیر نمی‌توانند در یک گونه همزیستی داشته باشند، زیرا گونه‌ی بازگشتی و پالایشگر `params` بخشی از امضای یک متد نیستند:
```Cs
void Foo (int x) {}
float Foo (int x) {} 

void Goo (int[] x) {}
void Goo (params int[] x) {} 
```

این که یک پارامتر با ارزش می‌گذرد یا با ارجاع، نیز بخشی از امضا است.
برای نمونه، `Foo(int)` می‌تواند با `Foo(ref int)` یا `Foo(out int)` همزیستی داشته باشد. با این همه، `Foo(ref int)` و `Foo(out int)` نمی‌توانند همزیستی داشته باشند:
```Cs
void Foo (int x) {}
void Foo (ref int x) {}
void Foo (out int x) {} 
```


### سازنده‌های نمونه‌ای (Instance Constructors)
سازنده‌ها کد آغازگری را در یک کلاس یا ساختار به کار می‌اندازند. یک سازنده مانند یک متد شناسایی می‌شود، جز اینکه نام متد و گونه‌ی بازگشتی به نام گونه‌ی دربرگیرنده کاهش می‌یابد:
```Cs
Panda p = new Panda ("Petey");

public class Panda
{
 string name;
 public Panda (string n)
 {
 name = n;
 }
}
```
سازنده های نمونه‌ای اجازه‌ی به‌کارگیری پالایشگرهای زیر را میدهند :
- پالایشگرهای دسترسی (Access modifiers)
`public internal private protected`
- پالایشگرهای کد بی‌مدیریت (Unmanaged code modifiers)
`unsafe extern`

سازنده های تک دستوری نیز میتوانند به عنوان اندام های بیان-پیکر نوشته شوند: 
```Cs
public Panda (string n) => name = n;
```
اگر نام یک پارامتر(یا هر نام متغیر دیگری) با نام یک فیلد هم‌پوشانی داشته باشد، میتوانید با پیشوند `this` فیلد را از هم باز شناسید:
```Cs
public Panda (string name ) => this.name = name;
```
برای نمونه  بهتر :
```Cs
public class LearnCsharp{
    public string name = "";

    public Panda(string name) => this.name = name;
    //در اصل نام اولی به فیلد اشاره میکند و دومی به پارامتر در  متد
}
```

### پربارسازی سازنده‌ها(Overloading constructors)
یک کلاس یا ساختار میتواند سازنده‌ها را پربارسازی کند.
برای پرهیز از تکرار کد(که خیلی مهم است )، یک سازنده میتواند سازنده‌ی دیگری را با بهره‌گیری از کلیدواژه‌ی `this` فراخوانی کند :
```Cs
public class Wine{
    public decimal Price;
    public int Year;
    public Wine (decimal price) => Price = price;
    public Wine (decimal price, int year) : this (price) => Year = year;    
}
```
زمانی که یک سازنده، دیگری را فراخوانی میکند، سازنده‌ی فراخوانده شده نخست اجرا میشود.

شما میتوانید یک بیان (expression) را به درون سازنده‌ی دیگر بفرستید، به گونه ای که در زیر آمده است :
```Cs
public Wine (decimal price, DateTime year) : this (price, year.Year) { }
```

این بیان می‌تواند به اندام های ایستا (static) کلاس دسترسی داشته باشد، اما به اندام های نمونه ای(instance) نه.

این نمونه‌ی ویژه میتواند به گونه‌ای بهتر با یک سازنده‌ی تکی که سال را به عنوان یک پارامتر دلخواه(optional) دارد ، پیاده سازی شود :
```Cs
public Wine (decimal price, int year = 0)
{
    Price = price; Year = year;
}
```


### سازنده‌های بدون پارامتر ضمنی (Implicit parameterless constructors)
برای کلاس‌ها گردآورنده‌ی C# به خودی خود یک سازنده‌ی بدون پارامتر `public` را تنها زمانی پدید می آورد که شما هیچ سازنده‌ای را شناسایی نکرده باشید.
با این همه ، به محض این که دست کم یک سازنده‌ را شناسایی کنید آن سازنده‌ی بدون بدون پارامتر دیگر به خودی خود پدیدار نمی‌شود.

برای درک بهتر این موضوع : 

```Cs
public class MyClass
{
}

MyClass obj1 = new MyClass();

public class MyClassWithConstructor
{
    public MyClassWithConstructor(int value)
    {
    }
}

MyClassWithConstructor obj2 = new MyClassWithConstructor(10);
```
به این معناست :
در زبان C#، اگر شما یک کلاس را تعریف کنید و هیچ سازنده‌ای برای آن مشخص نکنید، کامپایلر به طور خودکار یک سازنده‌ی بدون پارامتر (Implicit parameterless constructor) برای آن کلاس ایجاد می‌کند. اما اگر شما یک سازنده‌ی دیگر (مثلاً با پارامتر) تعریف کنید، آن سازنده‌ی بدون پارامتر دیگر به طور خودکار ایجاد نخواهد شد.


### ترتیب آغازگری سازنده و فیلد (Constructor and field initialization)
پیش از این دیدیم که فیلد‌ها می توانند با ارزش های پیش گزیده در شناسایی شان، آغاز گردنند:
```Cs
class player{
    int shields = 50;
    int health = 100;
}
```
آغازگری فیلدها پیش از اجرای سازنده و به ترتیب شناسایی فیلدها ، رخ میدهد

### سازنده‌های غیرهمگانی (Nonpublic constructors)
سازنده ها نیاز نیست `public` باشند.
یک شوند همگانی برای داشتن یک سازنده‌ی غیرهمگانی، چیره شدن بر پدیدآوری نمونه از راه یک فراخوانی متد `static` است. متد `static` می‌تواند برای بازگرداندن یک شیء از یک استخر (pool)، به جای پدیدآوری یک شیء نو، یا برای بازگرداندن زیرکلاس‌های گوناگون بر پایه‌ی آرگومان‌های ورودی به کار رود:

```Cs
public class Class1
{
 Class1() {}
 public static Class1 Create (...)
 {
 // Perform custom logic here to return an instance of Class1
 }
}
```

### پادسازنده‌ها (Deconstructors)
یک پادسازنده (که با نام "متد پادسازنده" نیز خوانده میشود) کارکردی درست برعکس یک سازنده دارد :
درحالی که یک سازنده به گونه‌ای همگانی یک سری از ارزش‌ها را (به عنوان پارامتر) می‌گیرد و به فیلدها می‌سپارد، یک پادسازنده کار برعکس را انجام می دهد و فیلدها را به  یک سری از متغیر ها میسپارد.

یک متد پادسازنده باید `Deconstruct` نامیده شود و باید یک یا چند پارامتر `out` داشته باشد، مانند نمونه زیر : 

```Cs
class Rectangle{
     public readonly float Width, Height;
    
    public Rectangle (float width, float height)
    {
        Width = width;
        Height = height;
    }
    
    
    public void Deconstruct (out float width, out float height)
    
    {
    
    width = Width;
    
    height = Height;
    
    }
}

```

دستور ویژه زیر ، پادسازنده را فراخوانی میکند:
```Cs
var rect = new Rectangle (3, 4);
(float width, float height) = rect; // پادسازی
Console.WriteLine (width + " " + height); // 3 4
```

سطر دوم، فراخوانی پادسازی است، . این سطر ، دو متغیر بومی را می‌سازد و سپس متد `Deconstruct` را فراخوانی میکند. 
فراخوانی پادسازی ما به نمونه‌ی زیر هم ارز است : 
```Cs
float width , height;
rect.Deconstruct(out width , out height);
```
یا :
```Cs
(var width, var height) = rect;
```

یا به سادگی به این گونه :
```Cs
var (width, height) = rect;
```

اگر به یک یا چند متغیر بی‌میل هستید ، می توانید از نماد دورریز(`_`) سی شارپ بهره ببرید : 
```Cs
var (_ , height) = rect;
```

این کار، به درستی نیت شما را نسبت به شناسایی یک متغیر که هرگز از آن بهره نمی برید  را نشان میدهد.

اگر متغیرهایی که در آن ها پادسازی می کنید از پیش شناسایی شده اند، می توانید گونه‌ها را به کلی نادیده بگیرید : 

```Cs
float width, height;
(width, height) = rect;
```

این کار، واگذاری پادسازی (**deconstructing assignment**) نامیده می‌شود. شما می‌توانید از یک واگذاری پادسازی برای ساده‌تر کردن سازنده‌ی کلاس خود بهره ببرید:

```Cs
public Rectangle (float width, float height) =>
 (Width, Height) = (width, height);
```

شما می‌توانید با پربارسازی متد `Deconstruct،` گزینه‌های گوناگونی برای پادسازی به فراخواننده پیشکش کنید.

متد `Deconstruct` می‌تواند یک متد گسترشی (**extension method**) باشد. این کار یک ترفند کارآمد است اگر می‌خواهید گونه‌هایی را پادسازی کنید که شما نویسنده‌ی آن‌ها نبوده‌اید.

از **سی‌شارپ 10**، می‌توانید متغیرهای از پیش موجود و متغیرهای نو را زمانی که پادسازی می‌کنید، با هم درآمیزید:

```Cs
double x1 = 0;
(x1, double y2) = rect;
```


### آغازگرهای شیء (Object Initializers)

برای ساده‌ترک ردنآغازگری شیء، هر فیلد یا ویژگی(`property`) دسترسی پذیر یک شیء میتوانید از راه یک **آغازگر شیء** ، درست  پس از ساخت ، مقداردهی شود. برای نمونه ، کلاس زیر را در نظر بگیرید : 

```Cs
public class Bunny
{
    public string Name;
    public bool LikesCarrots, LikesHumans;
    public Bunny () {}
    public Bunny (string n) => Name = n;
}
```

با بهره‌گیری از آغازگرهای شیء، میتوانید نمونه های کلاس `Bunny` را به این گونه پدید آورید : 

```Cs
// به یاد داشته باشید که سازنده‌های بدون پارامتر می‌توانند پرانتزهای خالی را نادیده بگیرند
Bunny b1 = new Bunny { Name="Bo", LikesCarrots=true, LikesHumans=false };
Bunny b2 = new Bunny ("Bo") { LikesCarrots=true, LikesHumans=false };
```

کد برای ساخت `b1` و `b2` با کد زیر هم‌ارز است:
```Cs
Bunny temp1 = new Bunny();
temp1.Name = "Bo";
temp1.LikesCarrots = true;
temp1.LikesHumans = false;
Bunny b1 = temp1;

Bunny temp2 = new Bunny ("Bo");
temp2.LikesCarrots = true;
temp2.LikesHumans = false;
Bunny b2 = temp2;
```
متغیرهای موقت برای این هستند که اگر در زمان آغازگری، یک کژکاری (`exception`) رخ دهد، شما یک شیء نیمه‌آغازگری‌شده نداشته باشید.


> ### آغازگرهای شیء در برابر پارامترهای دلخواه (Optional Parameters)
>
> به جای وابستگی به آغازگرهای شیء، می‌توانستیم سازنده‌ی `Bunny` را به گونه‌ی زیر، با یک پارامتر بایسته (`mandatory`) و دو پارامتر دلخواه، بنویسیم:
> 
> ```csharp
> public Bunny (string name,
>  bool likesCarrots = false,
>  bool likesHumans = false)
> {
>  Name = name;
>  LikesCarrots = likesCarrots;
>  LikesHumans = likesHumans;
> }
> ```
> 
> این کار به ما پروانه‌ی ساخت یک `Bunny` را به این گونه می‌داد:
> 
> ```csharp
> Bunny b1 = new Bunny (name: "Bo",
>  likesCarrots: true);
> ```
> 
> به گونه‌ای تاریخی، وابستگی به سازنده‌ها برای آغازگری شیء، سودمند بود؛ چرا که به ما پروانه‌ی خواندنی-تنها کردن فیلدها (یا ویژگی‌های) `Bunny` را می‌داد. خواندنی-تنها کردن فیلدها یا ویژگی‌ها، یک شیوه‌ی نیکو است زمانی که هیچ چرایی برای دگرگونی آن‌ها در سراسر زندگی شیء نیست. با این همه، همان گونه که در آینده در گفتگو درباره‌ی ویژگی‌ها خواهیم دید، پالایشگر `init` که در سی‌شارپ 9 پدیدار شد، به ما پروانه‌ی رسیدن به این هدف را با آغازگرهای شیء می‌دهد.
>
> پارامترهای دلخواه، دو کاستی دارند. نخست این که در حالی که بهره‌گیری از آن‌ها در سازنده‌ها به گونه‌های خواندنی-تنها پروانه می‌دهد، به آسانی به دگرگونی‌های غیرمخرب (`nondestructive mutation`) پروانه نمی‌دهند. (درباره‌ی دگرگونی‌های غیرمخرب و راه‌کار این دشواری، در آینده خواهیم گفت).
>
> دومین کاستی پارامترهای دلخواه این است که زمانی که در کتابخانه‌های همگانی به کار می‌روند، جلوی سازگاری با نسخه‌های پیشین را می‌گیرند. این به آن شوند است که افزودن یک پارامتر دلخواه در آینده، سازگاری دودویی (`binary compatibility`) اسمبلی را با فراخوانندگان از پیش موجود از بین می‌برد.
>
> دشواری از این جاست که هر ارزش پارامتر دلخواه در فراخوانی‌گاه (`calling site`) پخته می‌شود. به سخن دیگر، سی‌شارپ، فراخوانی سازنده‌ی ما را به این گونه برمی‌گرداند:
> 
> ```csharp
> Bunny b1 = new Bunny ("Bo", true, false);
> ```
> 
> این کار پرمسئله است اگر ما نمونه‌ی `Bunny` را از یک اسمبلی دیگر بسازیم و در آینده با افزودن یک پارامتر دلخواه دیگر مانند `likesCats`، `Bunny` را دگرگون کنیم. اگر اسمبلی ارجاع‌دهنده دوباره گردآوری (`recompiled`) نشود، همچنان به فراخوانی سازنده‌ی (که اکنون نیست) با سه پارامتر ادامه می‌دهد و در زمان اجرا شکست می‌خورد.


## رجاع `this` (The `this` Reference)

ارجاع `this` به خود نمونه اشاره دارد. در نمونه‌ی زیر، متد `Marry` از `this` بهره می‌برد تا فیلد `mate` همراه را مقداردهی کند:
```cs
public class Panda
{
    public Panda Mate;
    public void Marry (Panda partner)
    {
        Mate = partner;
        partner.Mate = this;
    }
}
```
ارجاع `this` همچنین یک متغیر بومی یا پارامتر را از یک فیلد باز می‌شناساند؛ برای نمونه:
```cs
public class Test
{
    string name;
    public Test (string name) => this.name = name;
}
```
ارجاع `this` تنها در درون اندام‌های غیرایستای یک کلاس یا ساختار، کارآمد است.

### ویژگی‌ها (Properties)

ویژگی‌ها (`Properties`) از بیرون مانند فیلدها (`fields`) به نظر می‌رسند، اما در درون، آن‌ها همانند متدها (`methods`) دارای کارکرد (logic) هستند. برای نمونه، شما با نگاه کردن به کد زیر نمی‌توانید بگویید که `CurrentPrice` یک فیلد است یا یک ویژگی:


```Cs
Stock msft = new Stock();
msft.CurrentPrice = 30;
msft.CurrentPrice -= 3;
Console.WriteLine (msft.CurrentPrice);
```

یک ویژگی همانند یک فیلد اعلان میشود اما با یک بلوک `get` , `set` که به آن افزودهشده است.
این هم چگونگی پیاده‌سازی `CurrentPrice` به عنوان یک ویژگی : 

```Cs
public class Stock
{
    decimal currentPrice; // فیلد "پشتیبان" خصوصی (private "backing" field)
    public decimal CurrentPrice // ویژگی همگانی (public property)
    {
        get { return currentPrice; }
        set { currentPrice = value; }
    }
}
```

`get` و `set` نشان‌دهنده‌ی **دسترسی‌سازهای ویژگی (property accessors)** هستند. دسترسی‌ساز `get` زمانی اجرا می‌شود که ویژگی خوانده می‌شود. این دسترسی‌ساز باید یک ارزش از گونه‌ی ویژگی را بازگرداند. دسترسی‌ساز `set` زمانی اجرا می‌شود که ویژگی مقداردهی می‌شود. این دسترسی‌ساز یک پارامتر ضمنی با نام `value` از گونه‌ی ویژگی دارد که شما به گونه‌ای همگانی آن را به یک فیلد خصوصی (در این نمونه، `currentPrice`) می‌سپارید.

گرچه به ویژگی‌ها به همان شیوه‌ی فیلدها دسترسی می‌یابند، اما آن‌ها در این که به پیاده‌ساز، کنترل کاملی بر روی گرفتن و سپردن ارزششان می‌دهند، با هم دگرسانی دارند. این کنترل به پیاده‌ساز پروانه می‌دهد تا هر بازنمایی درونی (internal representation) که نیاز است را گزینش کند، بدون این که جزئیات درونی را به کارگیر ویژگی نمایش دهد. در این نمونه، متد `set` می‌تواند یک کژکاری (exception) را پرتاب کند اگر `value` بیرون از یک بازه‌ی درست باشد.

> در سراسر این کتاب، ما از فیلدهای همگانی به گونه‌ای گسترده بهره می‌بریم تا نمونه‌ها از پریشانی دور بمانند. در یک نرم‌افزار راستین، شما به گونه‌ای همگانی، ویژگی‌های همگانی را بر فیلدهای همگانی برتر می‌شمارید تا **کپسوله‌سازی (encapsulation)** را ترویج کنید.

ویژگی‌ها اجازه‌ی به‌کارگیری پالایشگرهای (modifiers) زیر را می‌دهند:
* **پالایشگر ایستا (Static modifier)**
  `static`
* **پالایشگرهای دسترسی (Access modifiers)**
  `public internal private protected`
* **پالایشگرهای ارث‌بری (Inheritance modifiers)**
  `new virtual abstract override sealed`
* **پالایشگرهای کد بی‌مدیریت (Unmanaged code modifiers)**
  `unsafe extern`



### ویژگی‌های خواندنی-تنها و محاسبه شده (Read-only and calculated properties)
یک ویژگی، **خواندنی-تنها (read-only)** است اگر تنها یک دسترسی‌ساز `get` را شناسایی کند و **نوشتنی-تنها (write-only)** است اگر تنها یک دسترسی‌ساز `set` را شناسایی کند. ویژگی‌های نوشتنی-تنها به ندرت به کار می‌روند.

یک ویژگی به گونه‌ای همگانی یک **فیلد پشتیبان (backing field)** ویژه برای نگهداری داده‌های زیربنایی دارد. با این همه، یک ویژگی می‌تواند از داده‌های دیگر نیز محاسبه شود:

```Cs
decimal currentPrice, sharesOwned;
public decimal Worth
{
    get { return currentPrice * sharesOwned; }
}

```


### ویژگی‌های بیان-پیکر (Expression-bodied properties)
شما می‌توانید یک ویژگی خواندنی-تنها (readonly) مانند نمونه‌ی پیشین ، را به گونه‌ای کوتاه‌تر به عنوان یک ویژگی بیان-پیکر (expression-bodied property) شناسایی کنید. یک پیکان فربه (=>) جای همه‌ی آکولادها و کلیدواژه های `get` و `return` را می گیرد:
```Cs
public decimal Worth => currentPrice * sharesOwned;
```
با یک ساختار نوشتاری (syntax) کمی بیشتر ، دسترسی سازهای `set` نیز میتوانند بیان-پیکر باشند : 
```Cs
public decimal Worth
{
    get => currentPrice * sharesOwned;
    set => sharesOwned = value / currentPrice;
}

```

### ویژگی های خودکار (Automatic properties)

همگانی ترین پیاده سازی برای یک ویژگی، یک `getter` و یا `setter` است که به سادگی یک فیلد خصوصی با همان گونه‌ی ویژگی را می خواند و می نویسد. یک شناسایی ویژگی خودکار ، به گردآورنده(compiler) دستور می‌دهد که این پیاده‌سازی را فراهم کند.
ما میتوانیم نخستین نمونه‌ی این بخش را با شناسایی `CurrentPrice` به عنوان یک ویژگی خودکار، بهتر کنیم :
```Cs
public class Stock
{
    // ...
    public decimal CurrentPrice { get; set; }
}
```
گردآورنده به گونه‌ای خودکار یک **فیلد پشتیبان خصوصی (private backing field)** با یک نام گردآورنده-ساخته که نمی توان به آن اشاره کرد ، پدید می‌آورد. 
دسترسی ساز `set` می تواند به عنوان `private` یا `protected` نشان‌گذاری شود ،
اگر می خواهید ویژگی را به گونه‌ی خواندنی-تنها (readonly) به گونه‌های دیگر نمایش دهید .
ویژگی های خودکار در سی شارپ 3 پدیدار شدند.


**پی نوشت مترجم :**
برای درک بهتر موضوع بالا یک نمونه کوچک مینویسم :
اگر بخواهید یکی از ویژگی‌ها را به صورت خواندنی-تنها تعریف کنید، می‌توانید فقط یک `getter` تعریف کنید و `setter` را حذف کنید:
```Cs
public class Stock
{
    // ویژگی خودکار برای قیمت جاری
    public decimal CurrentPrice { get; set; }

    // ویژگی خواندنی-تنها برای نام شرکت
    public string CompanyName { get; }

    // سازنده برای مقداردهی اولیه نام شرکت
    public Stock(string companyName)
    {
        CompanyName = companyName;
    }
}
```
و ویژگی های Automatic properties در سی شارپ یک ویژگی خوب است که در متن های قبلی هم در بخش سازنده ها هم به چشم خورد. که در آنجا با نام (Auto-implemented Constructors) دیدیم.



### آغازگرهای ویژگی (Property initializers)

شما میتوانید یک آغازگر ویژگی را به ویژگی  های خودکار، همانند فیلدها ، بیفزایید:

```Cs
public decimal CurrentPrice { get; set; } = 123;
```
این کار به `CurrentPrice` یک ارزش آغازین 123 میدهد.
ویژگی‌هایی که دارای یک آغازگر هستند، می‌توانند خواندنی-تنها باشند : 
```Cs
public int Maximum { get; } = 999;
```
درست همانند فیلدهای خواندنی-تنها (یا فقط-خواندنی)، ویژگی های خودکار خواندنی-تنها نیز می‌توانند در سازنده‌ی گونه، مقداردهی شوند.
این کار در ساخت گونه‌های تغییرناپذیر(`immutable`) سودمند است.

#### دسترسی get و set
دسترسی سازهای `get` و `set` می‌توانند سطح های دسترسی گوناگونی داشته باشند.
کارکرد همگانی برای این کار، داشتن یک ویژگی همگانی با یک پالایشگر دسترسی `internal` یا `private` بر روی `setter` است :

```Cs
public class Foo
{
    private decimal x;
    public decimal X
    {
        get { return x; }
        private set { x = Math.Round (value, 2); }
    }
}
```

به یاد داشته باشید که شما خود ویژگی را با سطح دسترسی پروانه دارتر (در این نمونه `public`) شناسایی میکنید و پالایشگر را به دسترسی‌سازی که میخواهید دسترسی کمتری داشته باشد ، می افزایید.

### دسترسی سازهای تنها-آغازگر(Init-only setter)
از سی شارپ 9، شما می توانید یک دسترسی ساز ویژگی را با `init` به جای `set` شناسایی کنید :

```Cs
public class Note
{
    public int Pitch { get; init; } = 20; // ویژگی "تنها-آغازگر"
    public int Duration { get; init; } = 100; // ویژگی "تنها-آغازگر"
}
```

این ویژگی های تنها-آغازگر (init-only properties) مانند ویژگی های خواندنی-تنها کار میکنند،
با این دگرسانی(تفاوت) که می‌توانند از راه یک **آغازگر شیء (object initializer)** نیز مقدار دهی شوند :
```Cs
var note = new Note { Pitch = 50 };
```

پس از آن ویژگی نمی تواند دگرگون (تغییر) شود :
```Cs
note.Pitch = 200; // کژکاری – دسترسی‌ساز تنها-آغازگر!
```

ویژگی‌های تنها-آغازگر حتی از درون کلاس خود نیز نمی توانند مقداردهی شوند، مگر از راه آغازگر ویژگی ، سازنده ، یا یک دسترسی ساز تنها-آغازگر دیگر این کار انجام شود.

راه جایگزین برای ویژگی های تنها-آغازگر، داشتن ویژگی های خواندنی-تنها است که آن ها را از راه یک سازنده، پر می کنید:

```Cs
public class Note
{
    public int Pitch { get; }
    public int Duration { get; }
    public Note (int pitch = 20, int duration = 100)
    {
        Pitch = pitch; Duration = duration;
    }
}

```

اگر کلاس بخشی از یک کتابخانه‌ی همگانی باشد، این شیوه سازگاری نسخه‌ها را دشوار می‌کند، چرا که افزودن یک پارامتر دلخواه به سازنده در آینده، سازگاری دودویی (`binary compatibility`) را با فراخوانندگان می‌شکند (در حالی که افزودن یک ویژگی تنها-آغازگر نو، چیزی را نمی‌شکند).

ویژگی‌های تنها-آغازگر یک سودمندی چشمگیر دیگر نیز دارند، که آن این است که آن‌ها به دگرگونی غیرمخرب (`nondestructive mutation`) پروانه می‌دهند، زمانی که همراه با رکوردها (`records`) به کار می‌روند.

همانند دسترسی‌سازهای `set` معمولی، دسترسی‌سازهای تنها-آغازگر نیز می‌توانند یک پیاده‌سازی را فراهم کنند:
```Cs
public class Note
{
    readonly int _pitch;
    public int Pitch { get => _pitch; init => _pitch = value; }
    // ...
}
```

به یاد داشته باشید که فیلد `_pitch` خواندنی-تنها است: به دسترسی‌سازهای تنها-آغازگر پروانه داده می‌شود تا فیلدهای خواندنی-تنهای کلاس خودشان را دگرگون کنند. (بدون این ویژگی، `_pitch` نیاز به نوشتنی بودن داشت، و کلاس در درونی تغییرناپذیر بودن شکست می‌خورد).

دگرگون کردن دسترسی‌ساز یک ویژگی از `init` به `set` (یا برعکس) یک دگرسانی شکننده دودویی **(binary breaking change)** است: هر کسی که به `اسمبلی` شما ارجاع دهد، باید `اسمبلی` خود را دوباره گردآوری کند.

این نباید زمانی که گونه‌های کاملاً تغییرناپذیر می‌سازید، یک مسئله باشد، چرا که گونه‌ی شما هرگز به ویژگی‌هایی با دسترسی‌ساز `set` (نوشتنی) نیاز نخواهد داشت.


### پیاده‌سازی ویژگی CLR

دسترسی‌سازهای ویژگی سی‌شارپ به گونه‌ی درونی به متدهایی با نام‌های `get_XXX` و `set_XXX` گردآوری می‌شوند:
```Cs
public decimal get_CurrentPrice {...}
public void set_CurrentPrice (decimal value) {...}
```

یک دسترسی‌ساز `init` مانند یک دسترسی‌ساز `set` پردازش می‌شود، اما با یک پرچم افزوده که در فرا داده‌های modreq دسترسی‌ساز set کدگذاری شده است.
دسترسی‌سازهای ویژگی غیرمجازی (`nonvirtual`) و ساده، از راه گردآورنده‌ی `JIT (Just-In-Time) `درون‌خطی (`inlined`) می‌شوند، که هر دگرسانی کارایی میان دسترسی به یک ویژگی و یک فیلد را از بین می‌برد. درون‌خطی‌سازی (`Inlining`) یک بهینه‌سازی است که در آن یک فراخوانی متد با بدنه‌ی آن متد جایگزین می‌شود.


### ایندکسرها (Indexers)

ایندکسرها (Indexers) ساختاری نوشتاری (syntax) سر راست را برای دسترسی به اندام‌ها (elements) در یک کلاس (class) یا ساختار(struct) فراهم میکنند که یک فهرست (list) یا واژه‌نامه(dictionary) از ارزش‌ها را کپسوله سازی می کنند.
 ایندکسرها مانند ویژگی‌ها هستند، اما از راه یک آرگومان اندیس (`index argument`) به جای یک نام ویژگی، به آن‌ها دسترسی پیدا می‌شود. کلاس `string` یک ایندکسر دارد که به شما پروانه می‌دهد به هر یک از ارزش‌های `char` آن از راه یک اندیس `int` دسترسی یابید:
 ```Cs
 string s = "hello";
Console.WriteLine (s[0]); // 'h'
Console.WriteLine (s[3]); // 'l'
```

ساختار نوشتاری برای بهره‌کیری از ایندکسرها ، ماننده  بهره‌گیری از آرایه‌ها است، با این دگرسانی که آرگومان(های) اندیس می‌تواند از هر گونه‌ای باشد.

ایندکسرها همان پالایشگرهایی (modifiers) را دارند که ویژگی‌ها دارند و می‌توانند به گونه‌ای با پرسشگر (null-conditionally) فراخوانی شوند، با افزودن یک علامت پرسش پیش از براکت مربع:

```Cs
string s = null;
Console.WriteLine (s?[0]); // چیزی نمی‌نویسد؛ کژکاری (error) ندارد.
```

#### پیاده‌سازی یک ایندکسر (Implementing an indexer)

برای نوشتن یک ایندکسر، یک ویژگی با نام `this` شناسایی کنید و آرگومان‌ها را در براکت‌های مربع بگذارید:
```Cs
class Sentence
{
    string[] words = "The quick brown fox".Split();
 
    public string this [int wordNum] // indexer
 
    {
 
        get { return words [wordNum]; }
 
        set { words [wordNum] = value; }
 
    }
}

```

این هم چگونگی بهره‌گیری از این ایندکسر:
```Cs
Sentence s = new Sentence();
Console.WriteLine (s[3]); // fox
s[3] = "kangaroo";
Console.WriteLine (s[3]); // kangaroo
```

یک گونه می‌تواند چندین ایندکسر را شناسایی کند که هر یک پارامترهایی از گونه‌های دگرسان دارند. یک ایندکسر همچنین می‌تواند بیش از یک پارامتر داشته باشد:

```Cs
public string this [int arg1, string arg2]
{
    get { ... } set { ... }
}

```

اگر دسترسی ساز `set` را نادیده بگیرید ، یک ایندکسر خواندنی-تنها می شود و می توانید از ساختار نوشتاری بیان-پیکر(expression-bodied syntax) برای کوتاه‌تر کردن شناسایی آن بهره ببرید:

```Cs
public string this [int wordNum] => words [wordNum];
```

#### پیاده‌سازی ایندکسر CLR (CLR indexer implementation)

ایندکسر ها به گونه‌ی درونی به متدهایی با نام های `get Item` و `set Item` به گونه‌ی زیر گردآوری می شوند:

```Cs
public string get_Item (int wordNum) {...}
public void set_Item (int wordNum, string value) {...}
```

### بهره‌گیری از اندیس‌ها و بازه‌ها با ایندکسرها (Using indices and ranges with indexers)

شما میتوانید با شناسایی یک ایندکسر با یک گونه‌ی پارامتری از `Index` یا `Range` از اندیس ها و بازه ها در کلاس های خود پشتیبانی کنید.
ما میتوانیم نمونه‌ی پیشین خود را با افزودن این ایندکسرها به کلاس `Sentence` گسترش بدیم:
```Cs
public string this [Index index] => words [index];
public string[] this [Range range] => words [range];
```
این کار ، نمونه‌ی زیر پروانه می دهد:
```Cs
Sentence s = new Sentence();
Console.WriteLine (s [^1]); // fox 
string[] firstTwoWords = s [..2]; // (The, quick)

```
> **پی نوشت مترجم**
> شاید کمی این بخش گیج کننده باشد یک نمونه خوب برای بهتر فهمیدن این ایندکسر ها :
> ```Cs
> public class MyDictionary
> {
>     private Dictionary<string, string> internalData = new Dictionary<string, string>();
> 
>     public string this[string key]
>     {
>         get { return internalData[key]; }
>         set { internalData[key] = value; }
>     }
> }
> ```
> و به این صورت میتوانیم از آن استفاده کنیم :
> ```Cs
> var myDict = new MyDictionary();
> myDict["سی شارپ"] = "یک زبان برنامه‌نویسی است";
> Console.WriteLine(myDict["سی شارپ"]);
> ```
> در اصل ایندکسر ها یک ابزار قدرتمند و قوی هستند که به ما این اجازه رو میدهند که یک کلاس یا > ساختار را مانند  یک آرایه یا واژه‌نامه(دیکشنری) با آن رفتار کنیم
>  به جای فراخوانی یک متد یا ویژگی برای دسترسی به اندام‌های درونی، می‌توانیم از نگارش [] بهره بگیریم.


### سازنده‌های اصلی (Primary Constructors) (C# 12)

از سی شارپ 12 ، شما میتوانید یک فهرست پارامتری را درست پس از شناسایی کلاس (یا ساختار) بگذارید:
```Cs
class Person (string firstName, string lastName)
{
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```

این کار به گردآورنده (compiler) دستور می‌دهد  تا به گونه‌ی خودکار یک سازنده‌ی اصلی(primary constructor) را با بهره گیری از پارامترهای سازنده اصلی (`lastName` و `firstName`) بسازد تا ما بتوانیم کلاس خود را به گونه‌ی زیر نمونه سازی کنیم :
```Cs
Person p = new Person ("Alice", "Jones");
p.Print(); // Alice Jones
```

سازنده‌های اصلی برای نمونه سازی (prototyping) و دیگر سناریو های ساده سودمند هستند.
راه جایگزین این بود که فیلدها را شناسایی کرده و یک سازنده را به گونه‌ی آشکار بنویسیم :
```Cs
class Person // (بدون سازنده‌های اصلی)
{
    string firstName, lastName; // شناسایی فیلد
    public Person (string firstName, string lastName) // سازنده
    {
        this.firstName = firstName; // سپردن فیلد
        this.lastName = lastName; // سپردن فیلد
    }
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```

سازنده‌ای که سیش ارپ می سازد ، اصلی خوانده میشود ، چرا که هر سازنده‌ی دیگری که شما به گونه‌ی آشکار بنویسید، باید آن را فراخوانی کند : 
```Cs
class Person (string firstName, string lastName)
{
    public Person (string firstName, string lastName, int age)
    : this (firstName, lastName) // باید سازنده‌ی اصلی را فراخوانی کند
    {
        // ...
    }
}

```
این کار تضمین می کند که پارامتر های سازنده اصلی همیشه پر می شوند.

> سی‌شارپ همچنین از رکوردها (**records**) پشتیبانی می‌کند. رکوردها نیز از سازنده‌های اصلی پشتیبانی می‌کنند؛ با این همه، گردآورنده یک گام افزوده با رکوردها برمی‌دارد و (به گونه‌ی پیش‌فرض) یک ویژگی **تنها-آغازگر** (**init-only**) همگانی برای هر پارامتر سازنده‌ی اصلی پدید می‌آورد. اگر این رفتار، دلخواه است، بهتر است به جای آن از رکوردها بهره ببرید.

سازنده های اصلی به دلیل محدودیت های زیر ، برای سناریو های ساده مناسب تر هستن :

- شما نمی توانید کد آغازگری افزوده به یک سازنده‌ی اصلی بیفزایید.

- اگرچه نشان دادن یک پارامتر سازنده‌ی اصلی به عنوان یک ویژگی همگانی ساده است، شما نمی‌توانید  به آسانی کارکرد (logic) پایش را در آن بگنجانید، مگر این که ویژگی خواندنی-تنها باشد.
 

سازنده های اصلی جایگزین سازنده‌ی بدون پارامتر پیش‌فرض می شوند که سی شارپ در غیر این صورت پدید می آورد.

### معنی‌شناسی سازنده‌ی اصلی (Primary constructor semantics)
برای درک این سازنده های اصلی چگونه کار میکنند ، ببنید که یک سازنده‌ی معمولی چگونه رفتار میکند :
```Cs
class Person
{
    public Person (string firstName, string lastName)
    {
        // ... do something with firstName, lastName
    }
}
```

زمانی که کد درون این سازنده به پایان میرسد ، پارامترهای `lastName` , `firstName` از دامنه(scope) بیرون می روند و نمی توان به آن‌ها دسترسی پیدا کرد. 
در برابر ، پارامتر های یک سازنده‌ی اصلی از دامنه بیرون نمی‌روند و می توان از هر جایی در کلاس، در سراسر زندگی شیء به آن‌ها دسترسی یافت.

- پارامتر های سازنده‌ی اصلی، سازه های ویژه‌ی سی شارپ هستند، نه فیلدها، گرچه گردآورنده (Compiler) در پس پرده، فیلدهای پنهانی را پدید می آورد تا ارزش های آن‌ها را در صورت نیاز ، نگه دارد.

### سازنده‌های اصلی و آغازگرهای فیلد/ویژگی (Primary constructors and field/property initializers)

دسترسی پذیری پارامترهای سازنده‌ی اصلی به آغازگرهای فیلد و ویژگی نیز گسترده می‌یاد. در نمونه‌ی زیر، ما از آغازگرهای فیلد و ویژگی بهره می بریم تا `firstName` را به یک فیلد همگانی و `lastName` را به یک ویژگی همگانی بسپاریم : 
```Cs
class Person (string firstName, string lastName)
{
    public readonly string FirstName = firstName; // فیلد
    public string LastName { get; } = lastName; // ویژگی
}
```

### پوشاندن پارامترهای سازنده‌ی اصلی (Masking primary constructor parameters)

فیلدها(یا ویژگی ها) می توانند نام پارامترهای سازنده‌ی اصلی را دوباره به کار ببرند:
```Cs
class Person (string firstName, string lastName)
{
    readonly string firstName = firstName;
    readonly string lastName = lastName;
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```
در این سناریو، فیلد یا ویژگی برتری دارد و پارامتر سازنده‌ی اصلی را می پوشاند، مگر در سمت راست آغازگرهای فیلد و ویژگی.

- درست مانند پارامترهای معمولی، پارامترهای سازنده‌ی اصلی نیز نوشتنی هستند. پوشاندن آن‌ها با یک فیلد خواندنی-تنهای همنام (همانند نمونه‌ی ما) به گونه‌ای کارآمد از دگرگونی آن‌ها در آینده پاسداری می‌کند.

### پایش پارامترهای سازنده‌ی اصلی (Validating primary constructor parameters)
گاهی اوقات سودمند است که در  آغازگرهای (Initializer آغازگر) فیلد، یک حسابگری(computation) را انجام دهیم : 
```Cs
new Person ("Alice", "Jones").Print(); // Alice Jones
class Person (string firstName, string lastName)
{
    public readonly string FullName = firstName + " " + lastName;
    public void Print() => Console.WriteLine (FullName);
}
```
در نمونه‌ی بعدی ، ما یک نسخه بزرگ-حرف(حروف بزرگ) از lastName را به یک فیلد همنام میسپاریم(و ارزش پیشین را می پوشانیم):
```cs
new Person ("Alice", "Jones").Print(); // Alice JONES
class Person (string firstName, string lastName)
{
    readonly string lastName = lastName.ToUpper();
    public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```

در آینده خواهیم گفت که چگونه کژکاری‌ها(Exception) را پرتاب کنیم.
این هم یک پیش نمونه برای نشان دادن این که چگونه می توان از این کار با سازنده‌های اصلی بهره بدر تا `lastName` را در زامن ساخت، پایش کنیم و مطمئن شویم که `null` نیست :
```Cs
new Person ("Alice", null); // throws ArgumentNullException
class Person (string firstName, string lastName)
{
    readonly string lastName = (lastName == null)
    ? throw new ArgumentNullException ("lastName")
    : lastName;
}

```

> (به یاد داشته باشید که کد درون یک آغازگر فیلد یا ویژگی زمانی اجرا می‌شود که شیء ساخته می‌شود، نه زمانی که به فیلد یا ویژگی دسترسی می‌یابند.)


در نمونه‌ی بعدی، ما یک پارامتر سازنده‌ی اصلی را به عنوان یک ویژگی خواندنی/نوشتنی نشان می‌دهیم:
```Cs
class Person (string firstName, string lastName)
{
    public string LastName { get; set; } = lastName;
}
```

افزودن پایش به این نمونه سرراست نیست، چرا که شما باید در دو جا آن را پایش کنید : 
در یک دسترسی‌ساز `set` ویژگی (که به گونه‌ی دستی پیاده سازی شده است) و در آغازگر ویژگی در این هنگام، بهتر است از میان‌بر سازنده‌های اصلی بگذریم و یک سازنده و فیلدهای پشتیبان را به گونه‌ی آشکار شناسایی کنیم.







