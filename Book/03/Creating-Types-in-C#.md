# فصل سوم : ایجاد انواع نوع داده در سی شارپ

<div align="left">
    ![Conventions-UsedThis-Book](.\assets\image\03\ImageStartChapter3.png)
</div>

در این فصل ما به سمت بررسی کردن انواع  داده و  اعضای نوع میپردازیم 

## کلاس ها

یک `کلاس` پرکاربردترین گونه از نوع ارجاعی است. ساده‌ترین ساختار ممکن برای اعلان یک کلاس این‌گونه است:
```Cs
class YourClassName{

}
```
یک کلاس پیچیده‌تر می‌تواند به صورت  اختیاری دارای بخش های زیر باشد : 
پیش از واژه کلیدی `class`:
صفت ها و اصلاح کننده های کلاس. اصلاح کننده های که تو در کلاس های  تو در تو نمیبینی ، عبارتند از : 
`partial` , `public` , `internal` , `abstract` , `sealed` , `static` و `unsage` 
پس از `YourClassName` : 
پارامتر های نوع عمومی (Generic Type) و محدودیت‌ها، یک کلاس پایه و رابط‌ها

### درون آکولاد ها {} : 
اعضای کلاس (این اعضا : متدها ، ویژگی ها، ایندکسرها، رویدادها ،فیلدها، سازنده‌ها ، عمگرهای سربار گذاری شده  و انواع تودرتو و یک فاینالیزر هستند).

این بخش تمام این سازه‌ها به جز صفت ها، توابع عملگر و واژه کلیدی `unsafe` را پوشش می دهد، 
که آن‌ها در فصل چهارم پوشش داده شده اند. بخش های زیر به شرح هر یک از اعضای کلاس می پردازد.


## فیلد ها (Fields) : 

یک فیلد یک متغیر است که بخشی از اعضای یک کلاس و استراکت به حساب می آید برای نمونه : 
```Cs
class Octopus{
    string name;
    public int age = 10;
}
```

فیلد ها اجازه استفاده از اصلاح‌کننده(modifers) رو دارند :
**اصلاح‌کننده‌** **استاتیک**(Static modifier) : `static` 
**اصلاح‌کننده** **دسترسی**(Access modifers ) : `public` `internal` `private` `protected`
**اصلاح‌کننده** **وراثت**(Inheritance modifier) : `new`
**اصلاح‌کننده** **ناایمن**(Unsafe modifier) : `unsafe`
**اصلاح‌کننده** **فقط-خواندنی**(Read-only modifier) : `readonly`
**اصلاح‌کننده نخ‌کشی**(Threading modifier) :  `volatile`

## پیمان‌نامه نام‌گذاری (Naming Conventions) : 
دو پیمان‌‌نامه  نام‌گذاری رایج برای فید های خصوصی وجود دارد: 
- `شتروار (camel-cased)` : firstName 
- `شتروار با خط زیرین (camel-cased with an underscore)` : _firstName 
پیمان نامه دوم به تو اجازه میده تا به سرعت فیلد‌های خصوصی را از پارامتر‌ها و متغیرهای محلی شناسایی کنی.
در بسیاری از زبان ها از پیمان‌نامه دوم استفاده میشود

## اصلاح‌کننده readonly
این اصلاح‌کننده ، فیلد را پس از ساخته شدن غیرقابل ویراش می کند.
یک فیلد فقط-خواندنی را می‌توان تنها در اعلان یا درون سازنده نوع دربرگیرنده آن مقداردهی کرد.

## مقداردهی اولیه فیلد : 
مقداردهی اولیه به فیلدها اختیاری است.
یک فیلد مقداردهی نشده ، یک مقدار پیش‌فرض دارد (برای نمونه : false , null , 0 , \0)
مقداردهی اولیه فیلد پیش از سازنده ها اجرا میشود : 
```Cs
public int Age = 10;
```
یک مقداردهی اولیه فیلد میتواند دربرگیرنده عبارت ها و فراخوانی متدها باشد : 
```Cs
static readonly string TempFolder = System.IO.Path.GetTempPath();
```
در اینجا ما از مقدار بازگشتی `GetTempPath` متغیر `TempFolder` را مقداردهی کردیم


## اعلان هم‌زمان چند فیلد (Declaring multiple fields together) : 

برای آسان سازی ، ما میتوانیم چندین فیلد را از یک نوع را با یک فهرست جداشده با کاما اعلان کنیم.
این روش مناسب برای اشتراک‌گذاری صفت ها و اصلاح‌کننده های فیلد است : 
```Cs
static readonly int legs = 8,
                    eyse = 2;
```

## ثابت ها (Constants) : 
یک ثابت به صورت ایستا و در زمان کامپایل ارزیابی میشود و کامپایلر در هر جایی که از آن استفاده شود ، مقدارش را جایگزین میکند (مانند ماکرو در زبان C++ ).
یک ثابت می‌تواند از نوع `string` , `char` , `bool`و هر یک از انواع عددی داخلی یا یک نوع `enum` باشد.


یک ثابت با واژه کلیدی `const` اعلان می‌شود و باید با یک مقدار مقداردهی اولیه شود.
برای نمونه : 
```Cs
public class Test{
    public const string Message = "Hello World!";
}
```
یک ثابت میتواند نقشی همانند یک فیلد `static readonly` داشته باشد ، اما بسیار محدودتر است،
هم از نظر نوع‌هایی که میتوانی به کار ببری و هم از نظر معنای مقداردهی اولیه فیلد.

یک ثابت همچنین با فیلد `static readonly` فرق دارد ، زیرا ارزیابی ثابت در زمان کامپایل رخ میدهد ، از این رو :
```Cs
public static double Circumference (double radius)
{
 return 2 * System.Math.PI * radius;
}
```
به این صورت کامپایل میشود : 
```Cs
public static double Circumference (double radius)
{
 return 6.2831853071795862 * radius;
}

```
برای عدد `PI` منطقی است که ثابت باشد ، چرا که مقدار آن در زمان کامپایل از پیش تعیین شده است.
در مقابل ، مقدار یک فیلد `static readonly` می تواند هر بار که برنامه اجرا می شود، متفاوت باشد:
```Cs
static readonly DateTime StartupTime = DateTime.Now;
```

یک فیلد `static readonly` هنگامی که یک مقدار را به اسمبلی های دیگر نمایش می‌دهی و ممکن است آن مقدار در نسخه بعدی تغییر کند ، مزیت دارد. برای نمونه ، فرض کن اسمبلی `X` یک ثابت را این گونه نمایش میدهد:
```Cs
public const decimal ProgramVersion = 2.3;
```
اگر اسمبلی `Y` به `X` ارجاع دهد و از این ثابت استفاده کند، مقدار `2.3` در زمان کامپایل در اسمبلی `Y` جاسازی می‌شود. این به این معنی است که اگر بعدها `X` با ثابت `2.4` دوباره کامپایل شود، `Y` همچنان از مقدار قدیمی `2.3` استفاده خواهد کرد، تا زمانی که `Y` دوباره کامپایل شود. یک فیلد `static readonly` از این مشکل جلوگیری می‌کند.
از نگاهی دیگر، هر مقداری که ممکن است در آینده تغییر کند، به تعریف «ثابت» نیست؛ بنابراین نباید به این شکل نمایش داده شود.

ثابت ها می توانند در درون یک متد نیز اعلان شوند : 
```Cs
void TestPI(){
    const double twoPI = 2 * System.Math.PI;
    //...
}
```
ثابت های غیر محلی اجازه استفاده از اصلاح کننده های زیر را دارند : 
**اصلاح‌کننده های دسترسی** : 
`private` `public` `internal` `protected`
**اصلاح‌کننده وراثت**:
`new`