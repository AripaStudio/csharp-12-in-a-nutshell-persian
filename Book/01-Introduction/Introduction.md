## آشنایی با سی‌شارپ و دات‌نت

سی‌شارپ یک زبان برنامه‌نویسی همه‌منظوره، با امنیت نوع (type-safe) و شی‌ءگرا است. هدف این زبان، افزایش بهره‌وری برنامه‌نویسان است. بدین منظور، سی‌شارپ بین سادگی، گویایی و عملکرد، تعادل ایجاد می‌کند. معمار اصلی این زبان از اولین نسخه آن، آندرس هجسلبرگ (خالق توربو پاسکال و معمار دلفی) بوده است.

زبان سی‌شارپ مستقل از بستر (platform neutral) است و با طیف وسیعی از محیط‌های اجرایی (runtimes) مختص هر بستر کار می‌کند.

## شی‌ءگرایی

سی‌شارپ یک پیاده‌سازی غنی از پارادایم شی‌ءگرایی است که شامل کپسوله‌سازی (encapsulation)، وراثت (inheritance) و چندریختی (polymorphism) می‌شود. کپسوله‌سازی به معنای ایجاد یک مرز در اطراف یک شیء برای جدا کردن رفتار بیرونی (عمومی) آن از جزئیات پیاده‌سازی داخلی (خصوصی) است. در ادامه، ویژگی‌های متمایز سی‌شارپ از منظر شی‌ءگرایی آمده است:

سامانه نوع یکپارچه:
بلوک ساختاری اساسی در سی‌شارپ، یک واحد کپسوله‌شده از داده‌ها و توابع است که نوع نامیده می‌شود. سی‌شارپ دارای یک سامانه نوع یکپارچه است که در آن همه انواع، در نهایت یک نوع پایه مشترک دارند. این بدان معناست که همه انواع، چه نشان‌دهنده اشیاء کسب‌وکار باشند و چه انواع اولیه مانند اعداد، از همان عملکرد پایه مشترک برخوردارند. به عنوان مثال، یک نمونه از هر نوع را می‌توان با فراخوانی متد تبدیل به رشته (ToString) آن، به رشته تبدیل کرد.

کلاس‌ها و رابط‌ها:
در یک پارادایم سنتی شی‌ءگرا، تنها نوع موجود، کلاس است. در سی‌شارپ، چندین نوع دیگر نیز وجود دارد که یکی از آن‌ها رابط است. رابط مانند کلاسی است که نمی‌تواند داده نگه دارد. این بدان معناست که تنها می‌تواند رفتار را تعریف کند (و نه وضعیت را)، که امکان وراثت چندگانه و همچنین جدایی بین مشخصات و پیاده‌سازی را فراهم می‌کند.

خصوصیات، متدها و رویدادها:
در پارادایم شی‌ءگرای محض، همه توابع، متد هستند. در سی‌شارپ، متدها تنها یکی از انواع اعضای تابع هستند که شامل خصوصیات (properties) و رویدادها (events) نیز می‌شوند (انواع دیگری هم وجود دارند). خصوصیات، اعضای تابعی هستند که بخشی از وضعیت یک شیء را کپسوله‌سازی می‌کنند، مانند رنگ یک دکمه یا متن یک برچسب. رویدادها نیز اعضای تابعی هستند که ساده‌سازی واکنش به تغییرات وضعیت شیء را به عهده دارند.

اگرچه سی‌شارپ در درجه اول یک زبان شی‌ءگرا است، اما از پارادایم برنامه‌نویسی تابعی نیز الهام گرفته است، به ویژه در موارد زیر:

توابع را می‌توان به عنوان مقادیر در نظر گرفت:
با استفاده از نمایندگان (delegates)، سی‌شارپ اجازه می‌دهد تا توابع به عنوان مقادیر به توابع دیگر فرستاده و از آن‌ها بازگردانده شوند.

سی‌شارپ از الگوهایی برای پاکی پشتیبانی می‌کند:
هسته اصلی برنامه‌نویسی تابعی، پرهیز از استفاده از متغیرهایی است که مقادیرشان تغییر می‌کند، به نفع الگوهای اعلانی. سی‌شارپ ویژگی‌های کلیدی برای کمک به این الگوها دارد، از جمله توانایی نوشتن توابع بی‌نام به صورت لحظه‌ای که متغیرها را "شکار" می‌کنند (عبارات لامبدا) و توانایی انجام برنامه‌نویسی لیست یا واکنشی از طریق عبارات پرس‌وجو. سی‌شارپ همچنین سوابق (records) را فراهم می‌کند که نوشتن انواع تغییرناپذیر (فقط خواندنی) را آسان می‌کند.

## امنیت نوع

سی‌شارپ در درجه اول یک زبان با امنیت نوع است، به این معنی که نمونه‌های انواع تنها می‌توانند از طریق پروتکل‌هایی که تعریف می‌کنند با یکدیگر تعامل داشته باشند، که این امر سازگاری داخلی هر نوع را تضمین می‌کند. به عنوان مثال، سی‌شارپ شما را از تعامل با یک نوع رشته به گونه‌ای که گویی یک نوع عدد صحیح است، باز می‌دارد.

به طور خاص‌تر، سی‌شارپ از تایپ ایستا (Static Typing) پشتیبانی می‌کند، به این معنی که زبان، امنیت نوع را در زمان کامپایل (Compile Time) اعمال می‌کند. این علاوه بر امنیت نوع است که در زمان اجرا (Runtime) نیز اعمال می‌شود. تایپ ایستا بخش بزرگی از خطاها را قبل از اجرای برنامه از بین می‌برد. بار بررسی صحت مطابقت انواع در یک برنامه را از آزمون‌های واحد زمان اجرا به کامپایلر منتقل می‌کند. این باعث می‌شود مدیریت برنامه‌های بزرگ بسیار آسان‌تر، قابل پیش‌بینی‌تر و مقاوم‌تر شود. علاوه بر این، تایپ ایستا به ابزارهایی مانند IntelliSense در ویژوال استودیو امکان می‌دهد تا به شما در نوشتن برنامه کمک کنند، زیرا برای یک متغیر مشخص، نوع آن را می‌داند و در نتیجه می‌داند چه متدهایی را می‌توانید روی آن متغیر فراخوانی کنید. چنین ابزارهایی همچنین می‌توانند هر جایی از برنامه شما که یک متغیر، نوع یا متد استفاده شده است را شناسایی کرده و امکان بازسازی (Refactoring) قابل اعتماد را فراهم کنند.

سی‌شارپ همچنین اجازه می‌دهد بخش‌هایی از کد شما از طریق کلمه کلیدی پویا (dynamic) به صورت پویا تایپ شوند. با این حال، سی‌شارپ همچنان یک زبان عمدتاً با تایپ ایستا باقی می‌ماند.

سی‌شارپ همچنین یک زبان قوی‌تایپ (Strongly Typed) نامیده می‌شود، زیرا قوانین نوع آن به شدت اعمال می‌شوند (چه به صورت ایستا و چه در زمان اجرا). به عنوان مثال، نمی‌توانید تابعی را که برای پذیرش یک عدد صحیح طراحی شده است، با یک عدد اعشاری فراخوانی کنید، مگر اینکه ابتدا به صراحت عدد اعشاری را به عدد صحیح تبدیل کنید. این به جلوگیری از اشتباهات کمک می‌کند.

## مدیریت حافظه

سی‌شارپ برای انجام مدیریت خودکار حافظه، به محیط زمان اجرا (runtime) متکی است. محیط زمان اجرای مشترک (Common Language Runtime) دارای یک جمع‌آوری‌کننده زباله (garbage collector) است که به عنوان بخشی از برنامه شما اجرا می‌شود و حافظه اشیائی را که دیگر به آن‌ها ارجاعی داده نمی‌شود، بازپس می‌گیرد. این کار برنامه‌نویسان را از آزادسازی صریح حافظه برای یک شیء رها می‌کند و مشکل اشاره‌گرهای نادرست که در زبان‌هایی مانند سی‌پلاس‌پلاس با آن‌ها مواجه می‌شدیم، از بین می‌برد.

سی‌شارپ اشاره‌گرها را به طور کامل حذف نمی‌کند: صرفاً آن‌ها را برای بیشتر وظایف برنامه‌نویسی غیرضروری می‌سازد. برای نقاط حساس به عملکرد (performance-critical hotspots) و تعامل‌پذیری (interoperability)، استفاده از اشاره‌گرها و تخصیص صریح حافظه در بلوک‌هایی که با عنوان "ناامن" (unsafe) علامت‌گذاری شده‌اند، مجاز است.

## پشتیبانی از بسترها

سی‌شارپ دارای محیط‌های اجرایی است که از بسترهای زیر پشتیبانی می‌کنند:

رومیزی ویندوز ۷ به بالا (برای برنامه‌های مشتری غنی، وب، سرور و خط فرمان)
سیستم‌عامل مک (برای برنامه‌های وب و خط فرمان – و برنامه‌های مشتری غنی از طریق مک کاتالیست)
لینوکس (برای برنامه‌های وب و خط فرمان)
اندروید و آی‌او‌اس (برای برنامه‌های موبایل)
دستگاه‌های ویندوز ۱۰ (ایکس‌باکس، سرفیس هاب و هولولنز) از طریق سکوی برنامه‌نویسی جهانی ویندوز (UWP)
همچنین فناوری‌ای به نام بلِیْزر وجود دارد که می‌تواند سی‌شارپ را به اسمبلیکد وب (web assembly) کامپایل کند که در مرورگر اجرا می‌شود.

## محیط‌های زمان اجرا (CLRs)، کتابخانه‌های کلاس پایه (BCLs) و رانتایم‌ها

پشتیبانی محیط زمان اجرا برای برنامه‌های سی‌شارپ شامل یک محیط زمان اجرای مشترک و یک کتابخانه کلاس پایه است. یک محیط زمان اجرا همچنین می‌تواند شامل یک لایه کاربردی سطح بالاتر باشد که شامل کتابخانه‌هایی برای توسعه برنامه‌های مشتری غنی، موبایل یا وب است (به تصویر ۱-۱ مراجعه کنید). محیط‌های زمان اجرای مختلف برای انواع مختلفی از برنامه‌ها و همچنین بسترهای متفاوت وجود دارند.

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/01/Runtime-architecture.png) 
  
</div>

## محیط زمان اجرای مشترک

یک محیط زمان اجرای مشترک (CLR) خدمات اساسی زمان اجرا را فراهم می‌کند، از جمله مدیریت خودکار حافظه و رسیدگی به خطاها. (کلمه "مشترک" به این واقعیت اشاره دارد که همین محیط زمان اجرا می‌تواند توسط سایر زبان‌های برنامه‌نویسی مدیریت شده، مانند اف‌شارپ، ویژوال بیسیک، و سی‌پلاس‌پلاس مدیریت شده، به اشتراک گذاشته شود.)

سی‌شارپ یک زبان "مدیریت شده" نامیده می‌شود، زیرا کد منبع را به کد مدیریت شده (managed code) کامپایل می‌کند که در قالب زبان میانی (Intermediate Language - IL) نمایش داده می‌شود. محیط زمان اجرای مشترک (CLR) زبان میانی را به کد بومی ماشین (native code)، مانند X64 یا X86، معمولاً دقیقاً قبل از اجرا تبدیل می‌کند. به این فرآیند کامپایل در لحظه (Just-In-Time - JIT) گفته می‌شود. کامپایل پیش از زمان اجرا (Ahead-of-Time compilation) نیز برای بهبود زمان راه‌اندازی با مجموعه‌های بزرگ یا دستگاه‌های با منابع محدود (و برای رعایت قوانین فروشگاه برنامه‌های آی‌او‌اس هنگام توسعه برنامه‌های موبایل) در دسترس است.

ظرف حاوی کد مدیریت شده، مجموعه (Assembly) نامیده می‌شود. یک مجموعه نه تنها شامل زبان میانی، بلکه شامل اطلاعات نوع (metadata) نیز هست. وجود اطلاعات نوع به مجموعه‌ها اجازه می‌دهد تا به انواع موجود در سایر مجموعه‌ها بدون نیاز به فایل‌های اضافی ارجاع دهند.

شما می‌توانید محتویات یک مجموعه را با ابزار ildasm مایکروسافت بررسی و جداسازی (disassemble) کنید. و با ابزارهایی مانند ILSpy یا JetBrains dotPeek، می‌توانید فراتر رفته و زبان میانی را به سی‌شارپ دیکامپایل (decompile) کنید. از آنجا که زبان میانی سطح بالاتری نسبت به کد بومی ماشین دارد، ابزارهای دیکامپایلر می‌توانند کار بسیار خوبی در بازسازی سی‌شارپ اصلی انجام دهند.

یک برنامه می‌تواند اطلاعات نوع خودش را پرس‌وجو کند (بازتاب - reflection) و حتی در زمان اجرا، زبان میانی جدیدی تولید کند (reflection.emit).

## کتابخانه کلاس پایه

یک محیط زمان اجرای مشترک (CLR) همیشه همراه با مجموعه‌ای از کتابخانه‌ها عرضه می‌شود که کتابخانه کلاس پایه (Base Class Library - BCL) نامیده می‌شوند. یک کتابخانه کلاس پایه، قابلیت‌های اصلی را به برنامه‌نویسان ارائه می‌دهد، مانند مجموعه‌ها (collections)، ورودی/خروجی، پردازش متن، مدیریت XML/JSON، شبکه‌سازی، رمزنگاری، تعامل‌پذیری (interop)، همروندی (concurrency) و برنامه‌نویسی موازی.

یک کتابخانه کلاس پایه همچنین انواعی را که خود زبان سی‌شارپ نیاز دارد (برای ویژگی‌هایی مانند شمارش، پرس‌وجو و ناهمگامی) پیاده‌سازی می‌کند و به شما امکان می‌دهد مستقیماً به ویژگی‌های محیط زمان اجرای مشترک (CLR)، مانند بازتاب و مدیریت حافظه، دسترسی پیدا کنید.

## محیط‌های اجرایی

یک محیط اجرایی (runtime) (که گاهی اوقات "چارچوب" (framework) نیز نامیده می‌شود) یک واحد قابل استقرار است که آن را دانلود و نصب می‌کنید. یک محیط اجرایی از یک محیط زمان اجرای مشترک (CLR) (همراه با کتابخانه کلاس پایه آن) به علاوه یک لایه کاربردی اختیاری خاص برای نوع برنامه‌ای که می‌نویسید – وب، موبایل، مشتری غنی و غیره – تشکیل شده است. (اگر در حال نوشتن یک برنامه کنسولی خط فرمان یا یک کتابخانه بدون رابط کاربری هستید، نیازی به لایه کاربردی ندارید.)

هنگام نوشتن یک برنامه، شما یک محیط اجرایی خاص را هدف قرار می‌دهید، به این معنی که برنامه شما از قابلیت‌هایی که آن محیط اجرایی فراهم می‌کند، استفاده می‌کند و به آن‌ها وابسته است. انتخاب محیط اجرایی شما همچنین تعیین می‌کند که برنامه شما از کدام بسترها پشتیبانی خواهد کرد.

جدول زیر گزینه‌های اصلی محیط‌های اجرایی را فهرست می‌کند:

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/01/Introduction-02.png) 
  
</div>

تصویر ۱-۲ این اطلاعات را به صورت گرافیکی نمایش می‌دهد و همچنین به عنوان راهنمایی برای مطالبی که در کتاب پوشش داده شده‌اند، عمل می‌کند.

<div align="center">
  
  ![Conventions-UsedThis-Book](../../assets/image/01/Introduction-03.png) 
  
</div>

##  .NET 8

دات‌نت ۸ محیط زمان اجرای متن‌باز و پرچم‌دار مایکروسافت است. شما می‌توانید برنامه‌های وب و کنسول را بنویسید که روی ویندوز، لینوکس و سیستم‌عامل مک اجرا می‌شوند؛ برنامه‌های مشتری غنی (rich-client) که روی ویندوز ۱۰ به بالا و سیستم‌عامل مک اجرا می‌شوند؛ و برنامه‌های موبایل که روی آی‌او‌اس و اندروید اجرا می‌شوند. این کتاب بر محیط زمان اجرای مشترک (CLR) و کتابخانه کلاس پایه (BCL) دات‌نت ۸ تمرکز دارد.

بر خلاف چارچوب دات‌نت (NET Framework.)، دات‌نت ۸ به صورت پیش‌فرض روی دستگاه‌های ویندوزی نصب نیست. اگر سعی کنید یک برنامه دات‌نت ۸ را بدون حضور محیط زمان اجرای صحیح اجرا کنید، پیامی ظاهر می‌شود که شما را به یک صفحه وب برای دانلود محیط زمان اجرا هدایت می‌کند. می‌توانید با ایجاد یک استقرار خودکفا (self-contained deployment)، که شامل بخش‌های مورد نیاز محیط زمان اجرا برای برنامه است، از این امر جلوگیری کنید.

تاریخچه به‌روزرسانی‌های دات‌نت به شرح زیر است: دات‌نت کور ۱.x → دات‌نت کور ۲.x → دات‌نت کور ۳.x → دات‌نت ۵ → دات‌نت ۶ → دات‌نت ۷ → دات‌نت ۸. پس از دات‌نت کور ۳، مایکروسافت واژه "کور" را از نام حذف کرد و از نسخه ۴ صرف‌نظر کرد تا از سردرگمی با چارچوب دات‌نت ۴.x که پیش از تمام محیط‌های اجرایی قبلی قرار دارد اما هنوز پشتیبانی می‌شود و به طور گسترده مورد استفاده است، جلوگیری کند.

این بدان معناست که مجموعه‌های کامپایل شده تحت دات‌نت کور ۱.x تا دات‌نت ۷، در بیشتر موارد، بدون تغییر تحت دات‌نت ۸ اجرا خواهند شد. در مقابل، مجموعه‌های کامپایل شده تحت (هر نسخه‌ای از) چارچوب دات‌نت معمولاً با دات‌نت ۸ ناسازگار هستند.

## Windows Desktop and WinUI 3

برای نوشتن برنامه‌های مشتری غنی که روی ویندوز ۱۰ به بالا اجرا می‌شوند، می‌توانید بین رابط‌های برنامه‌نویسی کاربردی کلاسیک رومیزی ویندوز (فرم‌های ویندوز و WPF) و رابط کاربری ویندوز ۳ انتخاب کنید. رابط‌های برنامه‌نویسی کاربردی رومیزی ویندوز بخشی از محیط زمان اجرای دسکتاپ دات‌نت هستند، در حالی که رابط کاربری ویندوز ۳ بخشی از بسته توسعه نرم‌افزاری برنامه‌های ویندوز (Windows App SDK) است (یک دانلود جداگانه).

رابط‌های برنامه‌نویسی کاربردی کلاسیک رومیزی ویندوز از سال ۲۰۰۶ وجود داشته‌اند و از پشتیبانی عالی کتابخانه‌های شخص ثالث و همچنین منابع غنی از سوالات پاسخ داده شده در سایت‌هایی مانند استک‌اُوِرفلو برخوردارند. رابط کاربری ویندوز ۳ در سال ۲۰۲۲ منتشر شد و برای نوشتن برنامه‌های غوطه‌ور و مدرن که شامل جدیدترین کنترل‌های ویندوز ۱۰ به بالا هستند، در نظر گرفته شده است. این رابط، جانشین سکوی برنامه‌نویسی جهانی ویندوز (UWP) است.

## MAUI

مویی (MAUI - رابط کاربری برنامه چندبستری) در درجه اول برای ایجاد برنامه‌های موبایل برای آی‌او‌اس و اندروید طراحی شده است، اگرچه می‌توان از آن برای برنامه‌های رومیزی که روی سیستم‌عامل مک و ویندوز از طریق مک کاتالیست و رابط کاربری ویندوز ۳ اجرا می‌شوند نیز استفاده کرد. مویی تکامل یافته زامارین (Xamarin) است و اجازه می‌دهد یک پروژه واحد چندین بستر را هدف قرار دهد.

برای برنامه‌های رومیزی چندبستری، یک کتابخانه شخص ثالث به نام آوالونیا (Avalonia) جایگزینی برای مویی ارائه می‌دهد. آوالونیا روی لینوکس نیز اجرا می‌شود و از نظر معماری ساده‌تر از مویی است (زیرا بدون لایه غیرمستقیم کاتالیست/رابط کاربری ویندوز عمل می‌کند). آوالونیا یک رابط برنامه‌نویسی کاربردی شبیه به WPF دارد، و همچنین یک افزونه تجاری به نام XPF ارائه می‌دهد که سازگاری تقریباً کاملی با WPF فراهم می‌کند.

 ## .NET Framework

چارچوب دات‌نت (NET Framework.)، محیط زمان اجرای اصلی مایکروسافت فقط برای ویندوز است که برای نوشتن برنامه‌های وب و مشتری غنی که (فقط) روی رومیزی/سرور ویندوز اجرا می‌شوند، به کار می‌رود. هیچ نسخه اصلی جدیدی برای آن برنامه‌ریزی نشده است، اگرچه مایکروسافت به دلیل وجود حجم زیادی از برنامه‌های موجود، به پشتیبانی و نگهداری نسخه ۴.۸ فعلی ادامه خواهد داد.

با چارچوب دات‌نت، محیط زمان اجرای مشترک (CLR) و کتابخانه کلاس پایه (BCL) با لایه کاربردی ادغام شده‌اند. برنامه‌های نوشته شده در چارچوب دات‌نت را می‌توان تحت دات‌نت ۸ مجدداً کامپایل کرد، اگرچه معمولاً نیاز به تغییراتی دارند. برخی از ویژگی‌های چارچوب دات‌نت در دات‌نت ۸ وجود ندارند (و برعکس).

چارچوب دات‌نت به صورت پیش‌فرض با ویندوز نصب می‌شود و به طور خودکار از طریق به‌روزرسانی ویندوز اصلاح (patch) می‌گردد. هنگامی که چارچوب دات‌نت ۴.۸ را هدف قرار می‌دهید، می‌توانید از ویژگی‌های سی‌شارپ ۷.۳ و نسخه‌های قبلی استفاده کنید. (می‌توانید با مشخص کردن یک نسخه زبان جدیدتر در فایل پروژه این را لغو کنید – این کار تمام جدیدترین ویژگی‌های زبان را باز می‌کند، به جز مواردی که نیاز به پشتیبانی از یک محیط زمان اجرای جدیدتر دارند.)

کلمه "دات‌نت" مدت‌هاست که به عنوان یک اصطلاح چترگونه برای هر فناوری‌ای که شامل کلمه "دات‌نت" است (چارچوب دات‌نت، دات‌نت کور، دات‌نت استاندارد و غیره) به کار رفته است.

این بدان معناست که تغییر نام دات‌نت کور به دات‌نت توسط مایکروسافت، ابهام نامطلوبی ایجاد کرده است. در این کتاب، هنگامی که ابهامی پیش می‌آید، به دات‌نت جدید به عنوان "دات‌نت ۵ به بالا" اشاره خواهیم کرد. و برای اشاره به دات‌نت کور و جانشینان آن، از عبارت "دات‌نت کور و دات‌نت ۵ به بالا" استفاده خواهیم کرد.

برای افزودن به سردرگمی، دات‌نت (۵ به بالا) یک چارچوب (framework) است، با این حال بسیار متفاوت از چارچوب دات‌نت (NET Framework.) است. از این رو، هر جا که ممکن باشد، اصطلاح "محیط زمان اجرا" (runtime) را به "چارچوب" (framework) ترجیح می‌دهیم.

## محیط‌های اجرایی خاص Niche Runtimes

همچنین محیط‌های اجرایی خاص زیر وجود دارند:

یونیتی (Unity): یک سکوی توسعه بازی است که اجازه می‌دهد منطق بازی با سی‌شارپ نوشته شود.

سکوی برنامه‌نویسی جهانی ویندوز (UWP): برای نوشتن برنامه‌های لمسی‌محور (touch-first) طراحی شده بود که روی رومیزی ویندوز ۱۰ به بالا و دستگاه‌ها، از جمله ایکس‌باکس، سرفیس هاب و هولولنز اجرا می‌شوند. برنامه‌های سکوی برنامه‌نویسی جهانی ویندوز در محیط ایزوله (sandboxed) اجرا می‌شوند و از طریق فروشگاه ویندوز منتشر می‌گردند. سکوی برنامه‌نویسی جهانی ویندوز از نسخه‌ای از محیط زمان اجرای مشترک (CLR) و کتابخانه کلاس پایه (BCL) دات‌نت کور ۲.۲ استفاده می‌کند و بعید است که این وابستگی به‌روزرسانی شود؛ در عوض، مایکروسافت توصیه کرده است که کاربران به جایگزین مدرن آن، یعنی رابط کاربری ویندوز ۳، روی بیاورند. اما از آنجا که رابط کاربری ویندوز ۳ تنها از رومیزی ویندوز پشتیبانی می‌کند، سکوی برنامه‌نویسی جهانی ویندوز همچنان برای هدف قرار دادن ایکس‌باکس، سرفیس هاب و هولولنز یک کاربرد خاص دارد.

چارچوب کوچک دات‌نت (NET Micro Framework.): برای اجرای کدهای دات‌نت روی دستگاه‌های تعبیه شده با منابع بسیار محدود (زیر یک مگابایت) است.

همچنین امکان اجرای کد مدیریت شده در داخل اس‌کیو‌ال سرور نیز وجود دارد. با ادغام محیط زمان اجرای مشترک (CLR) اس‌کیو‌ال سرور، می‌توانید توابع سفارشی، رویه‌های ذخیره شده (stored procedures) و تجمعات (aggregations) را در سی‌شارپ بنویسید و سپس آن‌ها را از اس‌کیو‌ال فراخوانی کنید. این قابلیت در ترکیب با چارچوب دات‌نت و یک محیط زمان اجرای مشترک "میزبان شده" (hosted CLR) کار می‌کند که یک محیط ایزوله را برای محافظت از یکپارچگی فرآیند اس‌کیو‌ال سرور اعمال می‌کند.

## تاریخچه‌ای کوتاه از سی‌شارپ

در ادامه، یک گاه‌شمار معکوس از ویژگی‌های جدید در هر نسخه سی‌شارپ، برای خوانندگانی که قبلاً با نسخه قدیمی‌تر زبان آشنا هستند، آورده شده است.

## تازه‌های سی‌شارپ ۱۲

سی‌شارپ ۱۲ همراه با ویژوال استودیو ۲۰۲۲ عرضه می‌شود و هنگامی که دات‌نت ۸ را هدف قرار می‌دهید، استفاده می‌شود.

## Collection expressions

به جای مقداردهی اولیه یک آرایه به شکل زیر:
```C#
char[] vowels = {'a','e','i','o','u'};
```

اکنون می‌توانید از براکت‌های مربعی (که یک عبارت مجموعه است) استفاده کنید:
```C#
char[] vowels = ['a','e','i','o','u'];
```
عبارات مجموعه دو مزیت عمده دارند. اول اینکه، همین نحو برای انواع مجموعه‌ای دیگر، مانند لیست‌ها و مجموعه‌ها (و حتی انواع اسپَن سطح پایین) نیز کار می‌کند:
```C#
List list         = ['a','e','i','o','u'];
HashSet set       = ['a','e','i','o','u'];
ReadOnlySpan span = ['a','e','i','o','u'];
```
دوم اینکه، آن‌ها نوع-هدف هستند، به این معنی که در سناریوهای دیگری که کامپایلر می‌تواند نوع را استنباط کند، می‌توانید نوع را حذف کنید، مانند هنگام فراخوانی متدها:
```C#
Foo (['a','e','i','o','u']);
void Foo (char[] letters) { ... }
```
برای جزئیات بیشتر، به "مقداردهنده‌های اولیه مجموعه و عبارات مجموعه" در صفحه ۲۰۵ مراجعه کنید.

## سازنده‌های اصلی در کلاس‌ها و ساختارها  Primary constructors in classes and structs

از سی‌شارپ ۱۲ به بعد، می‌توانید یک لیست پارامتر را مستقیماً پس از اعلان کلاس (یا ساختار) قرار دهید:

```C#

class Person (string firstName, string lastName)
{
  public void Print() => Console.WriteLine (firstName + " " + lastName);
}
```
این دستور به کامپایلر می‌گوید که به طور خودکار یک سازنده اصلی بسازد، که امکان استفاده زیر را فراهم می‌کند:

```C#

Person p = new Person ("Alice", "Jones");
p.Print();    // Alice Jones
```
این ویژگی از سی‌شارپ ۹ با رِکوردها وجود داشته است—که در آنجا رفتار کمی متفاوتی دارند. با رِکوردها، کامپایلر (به طور پیش‌فرض) یک خصوصیت init-only عمومی برای هر پارامتر سازنده اصلی ایجاد می‌کند. این مورد در کلاس‌ها و ساختارها صدق نمی‌کند؛ برای دستیابی به همین نتیجه، باید آن خصوصیات را به صراحت تعریف کنید:

```C#

class Person (string firstName, string lastName)
{
 public string FirstName { get; set; } = firstName;
 public string LastName { get; set; } = lastName;
 }
```
سازنده‌های اصلی در سناریوهای ساده به خوبی کار می‌کنند. ما ظرایف و محدودیت‌های آن‌ها را در "سازنده‌های اصلی (سی‌شارپ ۱۲)" در صفحه ۱۱۹ شرح می‌دهیم.

## پارامترهای پیش‌فرض عبارت‌های لامبدا Default lambda parameters

همانطور که متدهای عادی می‌توانند پارامترهایی با مقادیر پیش‌فرض تعریف کنند:

```C#

void Print (string message = "") => Console.WriteLine (message);
```
عبارت‌های لامبدا نیز می‌توانند:

C#

var print = (string message = "") => Console.WriteLine (message);
print ("Hello");
print ();
این ویژگی با کتابخانه‌هایی مانند رابط برنامه‌نویسی کاربردی حداقلی ای‌اس‌پی‌نت مفید است.

## نام مستعار برای هر نوع Alias any type

سی‌شارپ همیشه به شما اجازه داده است که با استفاده از دستور using، یک نام مستعار برای یک نوع ساده یا عمومی ایجاد کنید:

```C#

using ListOfInt = System.Collections.Generic.List;
var list = new ListOfInt();
```
از سی‌شارپ ۱۲ به بعد، این رویکرد با انواع دیگر نیز کار می‌کند، مانند آرایه‌ها و تاپِل‌ها:

```C#

using NumberList = double[];
using Point = (int X, int Y);
NumberList numbers = { 2.5, 3.5 };
Point p = (3, 4);
```
## سایر ویژگی‌های جدید

سی‌شارپ ۱۲ همچنین از آرایه‌های درون‌خطی، از طریق خصیصه [System.Runtime.CompilerServices.InlineArray] پشتیبانی می‌کند. این امکان ایجاد آرایه‌های با اندازه ثابت در یک ساختار را بدون نیاز به یک زمینه ناامن فراهم می‌کند و در درجه اول برای استفاده در رابط‌های برنامه‌نویسی کاربردی زمان اجرا در نظر گرفته شده است.

## تازه‌های سی‌شارپ ۱۱

سی‌شارپ ۱۱ همراه با ویژوال استودیو ۲۰۲۲ عرضه شد و به طور پیش‌فرض زمانی که دات‌نت ۷ را هدف قرار می‌دهید، استفاده می‌شود.

## عبارات رشته خام  Raw string literals

قرار دادن یک رشته در سه یا چند علامت نقل قول، یک عبارت رشته خام (raw string literal) ایجاد می‌کند که می‌تواند تقریباً هر توالی از کاراکترها را بدون نیاز به فرار (escaping) یا تکرار، شامل شود. این کار نمایش متن‌هایی مانند جیسون، اِکس‌اِم‌ال و اچ‌تی‌اِم‌ال، و همچنین عبارات منظم و کدهای منبع را آسان می‌کند:

```C#

 string raw = """<file path="c:\temp\test.txt"></file>""";
```
عبارات رشته خام می‌توانند چندخطی باشند و از درون‌یابی (interpolation) از طریق پیشوند $ پشتیبانی می‌کنند:

```C#

string multiLineRaw = $"""
  Line 1
  Line 2
  The date and time is {DateTime.Now}
 """;
```
استفاده از دو (یا بیشتر) علامت $ در پیشوند یک عبارت رشته خام، توالی درون‌یابی را از یک براکت آکولاد به دو (یا بیشتر) براکت آکولاد تغییر می‌دهد و به شما امکان می‌دهد براکت‌ها را در خود رشته نیز قرار دهید:

```C#

Console.WriteLine ($$"""{ "TimeStamp": "{{DateTime.Now}}" }""");
// Output: { "TimeStamp": "01/01/2024 12:13:25 PM" }
```
ما ظرایف این ویژگی را در "عبارات رشته خام (سی‌شارپ ۱۱)" در صفحه ۵۹ و "درون‌یابی رشته" در صفحه ۶۰ پوشش می‌دهیم.

## UTF-8 strings

با پسوند u8، شما عبارت‌های رشته‌ای را ایجاد می‌کنید که به جای یوتی‌اف-۱۶، در یوتی‌اف-۸ کدگذاری شده‌اند. این ویژگی برای سناریوهای پیشرفته مانند مدیریت سطح پایین متن‌های جیسون در نقاط حساس به عملکرد در نظر گرفته شده است:

```C#

ReadOnlySpan<byte> utf8 = "ab→cd"u8;  // Arrow symbol consumes 3 bytes
Console.WriteLine (utf8.Length);      // 7
```
نوع زیربنایی، ReadOnlySpan<byte> (فصل ۲۳) است، که می‌توانید با فراخوانی متد ToArray() آن را به یک آرایه بایت تبدیل کنید.

## الگوهای لیست

الگوهای لیست با مجموعه‌ای از عناصر در براکت‌های مربعی مطابقت دارند و با هر نوع مجموعه‌ای که قابل شمارش (با خصوصیت Count یا Length) و قابل اندیس‌گذاری (با یک اندیس‌گذار از نوع int یا System.Index) باشد، کار می‌کنند:

```C#

int[] numbers = { 0, 1, 2, 3, 4 };
Console.WriteLine (numbers is [0, 1, 2, 3, 4]);   // True
```
یک زیرخط با یک عنصر منفرد از هر مقداری مطابقت دارد، و دو نقطه با صفر یا بیشتر عنصر (یک برش) مطابقت دارند:

```C#

Console.WriteLine (numbers is [_, 1, .., 4]);     // True
```
یک برش می‌تواند با الگوی var دنبال شود – برای جزئیات به "الگوهای لیست" در صفحه ۲۴۳ مراجعه کنید.

## Required members

اعمال اصلاح‌کننده required به یک فیلد یا خصوصیت، مصرف‌کنندگان آن کلاس یا ساختار را مجبور می‌کند تا هنگام ساخت شیء، آن عضو را از طریق یک مقداردهنده اولیه شیء (object initializer) مقداردهی کنند:

```C#

Asset a1 = new Asset { Name = "House" };  // OK
Asset a2 = new Asset();                   // Error: will not compile!
class Asset { public required string Name; }
```
با این ویژگی، می‌توانید از نوشتن سازنده‌هایی با لیست‌های پارامتر طولانی اجتناب کنید، که می‌تواند زیرکلاس‌سازی را ساده‌تر کند. اگر مایل به نوشتن یک سازنده نیز باشید، می‌توانید خصیصه [SetsRequiredMembers] را اعمال کنید تا محدودیت عضو مورد نیاز را برای آن سازنده نادیده بگیرید – برای جزئیات به "اعضای مورد نیاز (سی‌شارپ ۱۱)" در صفحه ۱۳۶ مراجعه کنید.

## اعضای رابط استاتیک مجازی/انتزاعی Static virtual/abstract interface members

از سی‌شارپ ۱۱، رابط‌ها می‌توانند اعضا را به صورت static virtual یا static abstract اعلان کنند:

```C#

public interface IParsable
{
 static abstract TSelf Parse (string s);
}
```
این اعضا به عنوان توابع static در کلاس‌ها یا ساختارها پیاده‌سازی می‌شوند و می‌توانند به صورت چندریختی از طریق یک پارامتر نوع مقید فراخوانی شوند:

```C#

T ParseAny (string s) where T : IParsable => T.Parse (s);
```
توابع عملگر (Operator functions) نیز می‌توانند به صورت static virtual یا static abstract اعلان شوند. برای جزئیات، به "اعضای رابط استاتیک مجازی/انتزاعی" در صفحه ۱۵۳ و "چندریختی استاتیک" در صفحه ۲۶۰ مراجعه کنید. همچنین نحوه فراخوانی اعضای انتزاعی استاتیک از طریق بازتاب را در "فراخوانی اعضای رابط استاتیک مجازی/انتزاعی" در صفحه ۸۲۶ شرح می‌دهیم.

## ریاضیات عمومی

رابط System.Numerics.INumber (جدید در دات‌نت ۷) عملیات حسابی را در تمام انواع عددی یکپارچه می‌کند و امکان نوشتن متدهای عمومی مانند زیر را فراهم می‌سازد:

```C#

T Sum (T[] numbers) where T : INumber
{
  T total = T.Zero;
  foreach (T n in numbers)
    total += n;      // Invokes addition operator for any numeric type
  return total;
}
int intSum = Sum (3, 5, 7);
double doubleSum = Sum (3.2, 5.3, 7.1);
decimal decimalSum = Sum (3.2m, 5.3m, 7.1m);
```
INumber توسط تمام انواع عددی حقیقی و صحیح در دات‌نت (و همچنین char) پیاده‌سازی می‌شود و شامل چندین رابط است که تعریف‌های عملگر انتزاعی استاتیک مانند زیر را در بر می‌گیرد:

```C#

static abstract TResult operator + (TSelf left, TOther right);
```
ما این مبحث را در "عملگرهای چندریختی" در صفحه ۲۶۱ و "ریاضیات عمومی" در صفحه ۲۶۲ پوشش می‌دهیم.

## سایر ویژگی‌های جدید

نوعی که با اصلاح‌کننده دسترسی file مشخص می‌شود، تنها از درون همان فایل قابل دسترسی است و برای استفاده در مولدهای منبع (source generators) در نظر گرفته شده است:

```C#

file class Foo { ... }
```
سی‌شارپ ۱۱ همچنین عملگرهای بررسی‌شده (checked operators) را معرفی کرد (به "عملگرهای بررسی‌شده" در صفحه ۲۵۸ مراجعه کنید)، برای تعریف توابع عملگر که در بلوک‌های checked فراخوانی شوند (این مورد برای پیاده‌سازی کامل ریاضیات عمومی لازم بود). سی‌شارپ ۱۱ همچنین الزام به مقداردهی همه فیلدها در سازنده یک ساختار را کاهش داد (به "معناشناسی ساختاردهی ساختار" در صفحه ۱۴۲ مراجعه کنید).

در نهایت، انواع اعداد صحیح بومی‌اندازه nint و nuint که در سی‌شارپ ۹ معرفی شده بودند تا با فضای آدرس فرآیند در زمان اجرا (۳۲ یا ۶۴ بیت) مطابقت داشته باشند، در سی‌شارپ ۱۱ هنگامی که دات‌نت ۷ یا بالاتر را هدف قرار می‌دهید، بهبود یافتند. به طور خاص، تمایز زمان کامپایل بین این انواع و انواع زمان اجرای زیربنایی آن‌ها (IntPtr و UIntPtr) هنگام هدف قرار دادن دات‌نت ۷ به بالا، از بین رفته است. برای بحث کامل‌تر به "اعداد صحیح بومی‌اندازه" در صفحه ۲۶۶ مراجعه کنید.

## تازه‌های سی‌شارپ ۱۰

سی‌شارپ ۱۰ همراه با ویژوال استودیو ۲۰۲۲ عرضه شد و زمانی که دات‌نت ۶ را هدف قرار می‌دهید، استفاده می‌شود.

### فضاهای نام محدود به فایل

در حالت رایجی که تمام انواع یک فایل در یک فضای نام واحد تعریف می‌شوند، اعلان فضای نام محدود به فایل در سی‌شارپ ۱۰ از شلوغی کم می‌کند و یک سطح تورفتگی غیرضروری را حذف می‌کند:

```C#

namespace MyNamespace;  // Applies to everything that follows in the file.
class Class1 {}         // inside MyNamespace
class Class2 {}         // inside MyNamespace
```
### دستور using سراسری

هنگامی که یک دستور using را با کلمه کلیدی global پیشوند می‌کنید، این دستور به تمام فایل‌های پروژه اعمال می‌شود:

```C#

global using System;
global using System.Collection.Generic;
```
این به شما امکان می‌دهد از تکرار دستورات یکسان در هر فایل جلوگیری کنید. دستورات global using با using static نیز کار می‌کنند.

علاوه بر این، پروژه‌های دات‌نت ۶ اکنون از دستورات global using ضمنی پشتیبانی می‌کنند: اگر عنصر ImplicitUsings در فایل پروژه روی true تنظیم شود، رایج‌ترین فضاهای نام به طور خودکار وارد می‌شوند (بر اساس نوع پروژه کیت توسعه نرم‌افزاری). برای جزئیات بیشتر به "دستور global using" در صفحه ۹۶ مراجعه کنید.

### تغییر غیرمخرب برای انواع بی‌نام

سی‌شارپ ۹ کلمه کلیدی with را برای انجام تغییر غیرمخرب بر روی رِکوردها معرفی کرد. در سی‌شارپ ۱۰، کلمه کلیدی with با انواع بی‌نام نیز کار می‌کند:

```C#

var a1 = new { A = 1, B = 2, C = 3, D = 4, E = 5 };
var a2 = a1 with { E = 10 }; 
Console.WriteLine (a2);      // { A = 1, B = 2, C = 3, D = 4, E = 10 }
```
### نحو جدید تفکیک ساختار

سی‌شارپ ۷ نحو تفکیک ساختار (deconstruction syntax) را برای تاپِل‌ها (یا هر نوعی با متد Deconstruct) معرفی کرد. سی‌شارپ ۱۰ این نحو را فراتر برده و به شما اجازه می‌دهد انتساب و اعلان را در یک عملیات تفکیک ساختار ترکیب کنید:

```C#

var point = (3, 4);
double x = 0;
(x, double y) = point;
```
### مقداردهنده‌های اولیه فیلد و سازنده‌های بدون پارامتر در ساختارها

از سی‌شارپ ۱۰ به بعد، می‌توانید مقداردهنده‌های اولیه فیلد و سازنده‌های بدون پارامتر را در ساختارها قرار دهید (به "ساختارها" در صفحه ۱۴۲ مراجعه کنید). این‌ها تنها زمانی اجرا می‌شوند که سازنده به صراحت فراخوانی شود، و بنابراین به راحتی می‌توان آن‌ها را نادیده گرفت – مثلاً از طریق کلمه کلیدی default. این ویژگی در درجه اول به منظور بهره‌مندی رِکورد ساختارها معرفی شد.

### رِکورد ساختارها

رِکوردها ابتدا در سی‌شارپ ۹ معرفی شدند، جایی که به عنوان یک کلاس با قابلیت‌های کامپایلر-افزوده عمل می‌کردند. در سی‌شارپ ۱۰، رِکوردها می‌توانند ساختار نیز باشند:

```C#

record struct Point (int X, int Y);
```
قوانین در سایر موارد مشابه هستند: رِکورد ساختارها ویژگی‌های بسیار مشابهی با رِکورد کلاس‌ها دارند (به "رِکوردها" در صفحه ۲۲۷ مراجعه کنید). یک استثنا این است که خصوصیات تولید شده توسط کامپایلر در رِکورد ساختارها قابل نوشتن هستند، مگر اینکه اعلان رِکورد را با کلمه کلیدی readonly پیشوند کنید.

### بهبودهای عبارات لامبدا

نحو مربوط به عبارات لامبدا به روش‌های مختلفی بهبود یافته است. اول اینکه، تایپ ضمنی (var) مجاز است:

```C#

var greeter = () => "Hello, world";
```
نوع ضمنی برای یک عبارت لامبدا، یک دلیگیت Action یا Func است، بنابراین greeter در این حالت، از نوع Func است. شما باید به صراحت انواع پارامترها را بیان کنید:

```C#

var square = (int x) => x * x;
```
دوم، یک عبارت لامبدا می‌تواند یک نوع بازگشتی را مشخص کند:

```C#

var sqr = int (int x) => x;
```
این عمدتاً برای بهبود عملکرد کامپایلر با لامبداهای پیچیده تو در تو است. سوم، می‌توانید یک عبارت لامبدا را به یک پارامتر متد از نوع object، Delegate یا Expression ارسال کنید:

```C#

M1 (() => "test");   // Implicitly typed to Func
M2 (() => "test");   // Implicitly typed to Func
M3 (() => "test");   // Implicitly typed to Expression<Func<string>>
void M1 (object x) {}
void M2 (Delegate x) {}
void M3 (Expression x) {}
```
در نهایت، می‌توانید خصیصه‌ها را به متد هدف تولید شده توسط کامپایلر برای یک عبارت لامبدا (و همچنین پارامترها و مقدار بازگشتی آن) اعمال کنید:

```C#

Action a = [Description("test")] () => { };
```
برای جزئیات بیشتر به "اعمال خصیصه‌ها به عبارات لامبدا" در صفحه ۲۴۵ مراجعه کنید.

### الگوهای خصوصیت تو در تو

نحو ساده شده زیر در سی‌شارپ ۱۰ برای تطبیق الگوی خصوصیت تو در تو قانونی است (به "الگوهای خصوصیت" در صفحه ۲۴۱ مراجعه کنید):

```C#

var obj = new Uri ("https://www.linqpad.net");
if (obj is Uri { Scheme.Length: 5 }) ...
```
این معادل با:

```C#

if (obj is Uri { Scheme: { Length: 5 }}) ...
```
### عبارت آرگومان فراخواننده

یک پارامتر متد که به آن خصیصه [CallerArgumentExpression] را اعمال می‌کنید، یک عبارت آرگومان را از محل فراخوانی دریافت می‌کند:

```C#

Print (Math.PI * 2);
void Print (double number,
           [CallerArgumentExpression("number")] string expr = null)
  => Console.WriteLine (expr);
// Output: Math.PI * 2
```
این ویژگی عمدتاً برای کتابخانه‌های اعتبار سنجی و ادعا در نظر گرفته شده است (به "عبارت آرگومان فراخواننده" در صفحه ۲۴۷ مراجعه کنید).

### سایر ویژگی‌های جدید

دستور line# در سی‌شارپ ۱۰ بهبود یافته است تا امکان مشخص کردن یک ستون و محدوده را فراهم کند.

رشته‌های درون‌یابی شده در سی‌شارپ ۱۰ می‌توانند ثابت باشند، تا زمانی که مقادیر درون‌یابی شده نیز ثابت باشند.

رِکوردها می‌توانند متد ToString() را در سی‌شارپ ۱۰ seal کنند.

تحلیل انتساب قطعی سی‌شارپ بهبود یافته است به طوری که عباراتی مانند زیر کار می‌کنند:

```C#

if (foo?.TryParse ("123", out var number) ?? false)
  Console.WriteLine (number);
```
(پیش از سی‌شارپ ۱۰، کامپایلر خطایی تولید می‌کرد: "استفاده از متغیر محلی نامقداری شده 'number'.")

## تازه‌های سی‌شارپ ۹.۰

سی‌شارپ ۹.۰ همراه با ویژوال استودیو ۲۰۱۹ عرضه شد و زمانی که دات‌نت ۵ را هدف قرار می‌دهید، استفاده می‌شود.

### دستورات سطح بالا

با دستورات سطح بالا (به "دستورات سطح بالا" در صفحه ۴۱ مراجعه کنید)، می‌توانید برنامه‌ای را بدون بار اضافه متد Main و کلاس Program بنویسید:

```C#

using System;
Console.WriteLine ("Hello, world");
```
دستورات سطح بالا می‌توانند شامل متدها (که به عنوان متدهای محلی عمل می‌کنند) باشند. همچنین می‌توانید از طریق متغیر "جادویی" args به آرگومان‌های خط فرمان دسترسی پیدا کنید و یک مقدار به فراخواننده برگردانید. دستورات سطح بالا می‌توانند با اعلان‌های نوع و فضای نام دنبال شوند.

### تنظیم‌کننده‌های فقط مقداردهی اولیه

یک تنظیم‌کننده فقط مقداردهی اولیه (init-only setter) (به "تنظیم‌کننده‌های فقط مقداردهی اولیه" در صفحه ۱۱۶ مراجعه کنید) در اعلان خصوصیت، به جای کلمه کلیدی set از کلمه کلیدی init استفاده می‌کند:

```C#

class Foo { public int ID { get; init; } }
```
این خصوصیت مانند یک خصوصیت فقط خواندنی رفتار می‌کند، با این تفاوت که می‌تواند از طریق یک مقداردهنده اولیه شیء (object initializer) نیز تنظیم شود:

```C#

var foo = new Foo { ID = 123 };
```
این امر ایجاد انواع تغییرناپذیر (read-only) را که می‌توانند به جای سازنده از طریق یک مقداردهنده اولیه شیء مقداردهی شوند، ممکن می‌سازد و به جلوگیری از ضدالگوی سازنده‌هایی که تعداد زیادی پارامتر اختیاری را می‌پذیرند، کمک می‌کند. تنظیم‌کننده‌های فقط مقداردهی اولیه همچنین در هنگام استفاده در رِکوردها، امکان تغییر غیرمخرب را فراهم می‌کنند.

### رِکوردها

یک رِکورد (به "رِکوردها" در صفحه ۲۲۷ مراجعه کنید) نوع خاصی از کلاس است که برای کار با داده‌های تغییرناپذیر طراحی شده است. خاص‌ترین ویژگی آن این است که از تغییر غیرمخرب از طریق یک کلمه کلیدی جدید (with) پشتیبانی می‌کند:

```C#

Point p1 = new Point (2, 3);
Point p2 = p1 with { Y = 4 };   // p2 is a copy of p1, but with Y set to 4
Console.WriteLine (p2);         // Point { X = 2, Y = 4 }
```
```C#

record Point
 {
  public Point (double x, double y) => (X, Y) = (x, y);
  public double X { get; init; }
  public double Y { get; init; }    
}
```
در موارد ساده، یک رِکورد می‌تواند کد قالبی تعریف خصوصیات و نوشتن سازنده و تفکیک‌کننده را نیز حذف کند. می‌توانیم تعریف رِکورد Point خود را بدون از دست دادن کارایی، با کد زیر جایگزین کنیم:

```C#

record Point (double X, double Y);
```
مانند تاپِل‌ها، رِکوردها به طور پیش‌فرض برابری ساختاری را نشان می‌دهند. رِکوردها می‌توانند از رِکوردهای دیگر زیرکلاس بسازند و می‌توانند شامل همان ساختارهایی باشند که کلاس‌ها می‌توانند شامل شوند. کامپایلر رِکوردها را در زمان اجرا به عنوان کلاس پیاده‌سازی می‌کند.

### بهبودهای تطبیق الگو

الگوی رابطه‌ای (به "الگوها" در صفحه ۲۳۸ مراجعه کنید) به عملگرهای <, >, <=, و >= اجازه می‌دهد در الگوها ظاهر شوند:

```C#

string GetWeightCategory (decimal bmi) => bmi switch {
 < 18.5m => "underweight",
 < 25m => "normal",
 < 30m => "overweight",
  _ => "obese" };
```
با ترکیب‌کننده‌های الگو، می‌توانید الگوها را از طریق سه کلمه کلیدی جدید (and, or, و not) ترکیب کنید:

```C#

bool IsVowel (char c) => c is 'a' or 'e' or 'i' or 'o' or 'u';
bool IsLetter (char c) => c is >= 'a' and <= 'z'
 or >= 'A' and <= 'Z';
```
مانند عملگرهای && و ||، عملگر and اولویت بالاتری نسبت به or دارد. می‌توانید با پرانتز این اولویت را نادیده بگیرید.

ترکیب‌کننده not می‌تواند با الگوی نوع استفاده شود تا آزمایش کند که آیا یک شیء (نه) از یک نوع خاص است:

```C#

if (obj is not string) ...
```
### عبارات new نوع-هدف Target-typed new expressions

هنگام ساخت یک شیء، سی‌شارپ ۹ به شما اجازه می‌دهد نام نوع را زمانی که کامپایلر می‌تواند به طور unambiguous آن را استنباط کند، حذف کنید:

```C#

System.Text.StringBuilder sb1 = new();
System.Text.StringBuilder sb2 = new ("Test");
```
این به ویژه زمانی مفید است که اعلان متغیر و مقداردهی اولیه در بخش‌های مختلف کد شما قرار دارند:

```C#

class Foo
{
 System.Text.StringBuilder sb;
  public Foo (string initialValue) => sb = new (initialValue);
 }
```
و در سناریوی زیر:

```C#

MyMethod (new ("test"));
void MyMethod (System.Text.StringBuilder sb) { ... }
```
برای اطلاعات بیشتر به "عبارات new نوع-هدف" در صفحه ۷۷ مراجعه کنید.

### بهبودهای تعامل‌پذیری

سی‌شارپ ۹ اشاره‌گرهای تابع (function pointers) را معرفی می‌کند (به "اشاره‌گرهای تابع" در صفحه ۲۶۸ و "فراخوانی‌های برگشتی با اشاره‌گرهای تابع" در صفحه ۹۹۱ مراجعه کنید). هدف اصلی آن‌ها این است که به کدهای مدیریت‌نشده اجازه دهند متدهای static را در سی‌شارپ بدون سربار یک نمونه دلیگیت فراخوانی کنند، با قابلیت نادیده گرفتن لایه فراخوانی تابع خارجی (P/Invoke) زمانی که آرگومان‌ها و انواع بازگشتی از نوع blittable هستند (یعنی در هر دو سمت به یک شکل نمایش داده می‌شوند).

سی‌شارپ ۹ همچنین انواع اعداد صحیح بومی‌اندازه nint و nuint را معرفی می‌کند (به "اعداد صحیح بومی‌اندازه" در صفحه ۲۶۶ مراجعه کنید)، که در زمان اجرا به System.IntPtr و System.UIntPtr نگاشت می‌شوند. در زمان کامپایل، آن‌ها مانند انواع عددی با پشتیبانی از عملیات حسابی رفتار می‌کنند.

### سایر ویژگی‌های جدید

علاوه بر این، سی‌شارپ ۹ اکنون به شما اجازه می‌دهد:

یک متد یا خصوصیت فقط خواندنی را به گونه‌ای بازنویسی کنید که یک نوع مشتق‌شده‌تر را برگرداند (به "انواع بازگشتی کوواریانت" در صفحه ۱۳۱ مراجعه کنید).
خصوصیات (Attributes) را به توابع محلی اعمال کنید (به "خصوصیات" در صفحه ۲۴۳ مراجعه کنید).
کلمه کلیدی static را به عبارات لامبدا یا توابع محلی اعمال کنید تا مطمئن شوید که به طور تصادفی متغیرهای محلی یا نمونه را شکار نمی‌کنید (به "لامبداهای استاتیک" در صفحه ۱۹۲ مراجعه کنید).
با نوشتن یک متد توسعه‌دهنده GetEnumerator، هر نوعی را با دستور foreach سازگار کنید.
یک متد مقداردهنده اولیه ماژول تعریف کنید که با اولین بارگذاری یک اَسمبلی یک بار اجرا می‌شود، با اعمال خصیصه [ModuleInitializer] به یک متد (static void بدون پارامتر).
از یک "بازیافت" (نماد زیرخط) به عنوان آرگومان عبارت لامبدا استفاده کنید.
متدهای partial توسعه‌یافته بنویسید که پیاده‌سازی آن‌ها اجباری است – امکان سناریوهایی مانند مولدهای منبع جدید Roslyn را فراهم می‌کند (به "متدهای partial توسعه‌یافته" در صفحه ۱۲۵ مراجعه کنید).
یک خصیصه را به متدها، انواع یا ماژول‌ها اعمال کنید تا از مقداردهی اولیه متغیرهای محلی توسط زمان اجرا جلوگیری شود (به "[SkipLocalsInit]" در صفحه ۲۶۹ مراجعه کنید).
## تازه‌های سی‌شارپ ۸.۰

سی‌شارپ ۸.۰ ابتدا همراه با ویژوال استودیو ۲۰۱۹ عرضه شد و امروزه همچنان زمانی که دات‌نت کور ۳ یا دات‌نت استاندارد ۲.۱ را هدف قرار می‌دهید، استفاده می‌شود.

### اندیس‌ها و محدوده‌ها

اندیس‌ها و محدوده‌ها کار با عناصر یا بخش‌هایی از یک آرایه (یا انواع سطح پایین Span و ReadOnlySpan) را ساده می‌کنند.

اندیس‌ها به شما اجازه می‌دهند با استفاده از عملگر ^ به عناصر نسبت به انتهای یک آرایه ارجاع دهید. ^1 به آخرین عنصر، ^2 به عنصر یکی مانده به آخر و غیره ارجاع می‌دهد:

```C#

char[] vowels = new char[] {'a','e','i','o','u'};
char lastElement  = vowels [^1];   // 'u'
char secondToLast = vowels [^2];   // 'o'
```
محدوده‌ها به شما اجازه می‌دهند با استفاده از عملگر .. یک آرایه را "برش" دهید:

```C#

char[] firstTwo =  vowels [..2];    // 'a', 'e'
char[] lastThree = vowels [2..];    // 'i', 'o', 'u'
char[] middleOne = vowels [2..3]    // 'i'
char[] lastTwo =   vowels [^2..];   // 'o', 'u'
```
سی‌شارپ اندیس‌ها و محدوده‌ها را با کمک انواع Index و Range پیاده‌سازی می‌کند:

```C#

Index last = ^1;
Range firstTwoRange = 0..2;
char[] firstTwo = vowels [firstTwoRange];   // 'a', 'e'
```
شما می‌توانید با تعریف یک اندیس‌گذار با نوع پارامتر Index یا Range، از اندیس‌ها و محدوده‌ها در کلاس‌های خودتان پشتیبانی کنید:

```C#

class Sentence
{
  string[] words = "The quick brown fox".Split();
  public string this   [Index index] => words [index];
  public string[] this [Range range] => words [range];
}
```
برای اطلاعات بیشتر، به "اندیس‌ها و محدوده‌ها" در صفحه ۶۳ مراجعه کنید.

